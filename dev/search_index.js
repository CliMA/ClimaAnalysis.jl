var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"APIs","title":"API","text":"","category":"section"},{"location":"api/#Sim","page":"APIs","title":"Sim","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Sim.SimDir","page":"APIs","title":"ClimaAnalysis.Sim.SimDir","text":"SimDir(simulation_path::String)\n\nObject that describes all the ClimaAtmos output found in the given simulation_path.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.get-Tuple{SimDir}","page":"APIs","title":"Base.get","text":"get(simdir::SimDir;\n    short_name,\n    reduction = nothing,\n    period = nothing)\n\nReturn a OutputVar for the corresponding combination of short_name, reduction, and period (if it exists).\n\nThe variable is read only once and saved into the simdir.\n\nKeyword arguments\n\nWhen passing nothing to reduction and period, ClimaAnalysis will try to automatically deduce the value. An error will be thrown if this is not possible.\n\nFor instance, if the simulation has only one ta, you do not need to specify short_name, reduction, and period (short_name is enough). Similarly, if there is only one ta_average (ie, not multiple periods), short_name and reduction will be enough.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{SimDir, Vararg{Any}}","page":"APIs","title":"Base.get","text":"get(simdir::SimDir, short_names...)\n\nIf only one reduction and period exist for the given short_names, return the corresponding OutputVars.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Sim.available_vars-Tuple{SimDir}","page":"APIs","title":"ClimaAnalysis.Sim.available_vars","text":"available_vars(simdir::SimDir)\n\nReturn the short names of the variables found in the given simdir.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Sim.available_reductions","page":"APIs","title":"ClimaAnalysis.Sim.available_reductions","text":"available_reductions(simdir::SimDir, short_name::String)\n\nReturn the reductions available for the given variable in the given simdir.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Sim.available_periods","page":"APIs","title":"ClimaAnalysis.Sim.available_periods","text":"available_periods(simdir::SimDir, short_name::String, reduction::String)\n\nReturn the periods associated to the given variable and reduction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.show-Tuple{IO, SimDir}","page":"APIs","title":"Base.show","text":"Base.show(io::IO, simdir::SimDir)\n\nPretty print the contents of simdir.\n\nPrint the output directory and the periods associated to the given variable and reduction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catalog","page":"APIs","title":"Catalog","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Catalog.NCCatalog","page":"APIs","title":"ClimaAnalysis.Catalog.NCCatalog","text":"Organize external NetCDF files to easily initialize `OutputVar`s.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Catalog.NCCatalog-Tuple{}","page":"APIs","title":"ClimaAnalysis.Catalog.NCCatalog","text":"NCCatalog()\n\nConstruct an empty NCCatalog.\n\nFiles can be added with ClimaAnalysis.Catalog.add_file!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Catalog.add_file!","page":"APIs","title":"ClimaAnalysis.Catalog.add_file!","text":"add_file!(catalog::NCCatalog, filepath, short_names...)\n\nAdd the file at filepath to catalog with short_names.\n\nThe argument short_names can either be a short name (e.g., \"rsdt\") or a pair of strings (e.g., \"solar_mon\" => \"rsdt\"). If a pair is used, then the first name is the variable name in the NetCDF file and the second name is the alias which will be used for get.\n\nnote: Multiple files with the same short names\nIf there are multiple files that contain the same short names, then you should pass in the desired file first or pass in a short name or a pair of short name to alias for short_names to make the variable in the file retrievable with get.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.get-Tuple{NCCatalog, Any}","page":"APIs","title":"Base.get","text":"get(catalog::NCCatalog, short_name; var_kwargs)\n\nReturn a OutputVar with short_name from catalog.\n\nThe keyword argument var_kwargs is a tuple of keyword arguments passed to OutputVar. See ClimaAnalysis.Var.OutputVar for a list of keyword arguments that can be passed.\n\nAny short names or aliases specified when adding files are searched first to identify which variable to load. If short_name cannot be found, then files are searched in the order that the files are added to identify which variable to load.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Sim.available_vars-Tuple{NCCatalog}","page":"APIs","title":"ClimaAnalysis.Sim.available_vars","text":"available_vars(catalog::NCCatalog)\n\nReturn the short names of the variables found in catalog.\n\nBoth aliases and variable names in the NetCDF files are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Var","page":"APIs","title":"Var","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Var.OutputVar","page":"APIs","title":"ClimaAnalysis.Var.OutputVar","text":"Representing an output variable\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.read_var","page":"APIs","title":"ClimaAnalysis.Var.read_var","text":"read_var(path::String; short_name = nothing)\n\nRead the short_name variable in the given NetCDF file.\n\nWhen short_name is nothing, automatically identify the name of the variable. If multiple variables are present, the last one in alphabetical order is chosen.\n\nWhen units is among the attributes, try to parse it and convert it into an Unitful object. OutputVars with Unitful support automatic unit conversions.\n\nIf you want to access units as a string, look at units function.\n\nExample\n\nsimdir = SimDir(\"my_output\")\nread_var(simdir.variable_paths[\"hu\"][\"inst\"])\n\nread_var(\"my_netcdf_file.nc\", short_name = \"ts\")\n\n\n\n\n\nread_var(paths::Vector{String}; short_name = nothing)\n\nRead the short_name variable in the vector of NetCDF files.\n\nThis function automatically aggregates the NetCDF files along the time dimension. If this is not possible, then an error is thrown. The attributes of the OutputVar is the same as the attributes of the first NetCDF file.\n\nWhen short_name is nothing, automatically identify the name of the variable. If multiple variables are present, the last one in alphabetical order is chosen.\n\nWhen units is among the attributes, try to parse it and convert it into an Unitful object. OutputVars with Unitful support automatic unit conversions.\n\nIf you want to access units as a string, look at units function.\n\nExample\n\nsimdir = SimDir(\"my_output\")\nread_var(simdir.variable_paths[\"hu\"][\"inst\"])\n\nread_var([\"my_netcdf_file1.nc\", \"my_netcdf_file2.nc\"], short_name = \"ts\")\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.is_z_1D","page":"APIs","title":"ClimaAnalysis.Var.is_z_1D","text":"is_z_1D(var::OutputVar)\n\nReturn whether the given variable has an altitude dimension that is 1D.\n\nWhen topography is present, the altitude dimension in the output variable is typically multidimensional. The dimensions are (X, Y, Z), where (X, Y) are the horizontal dimensions. In this case, dims[\"z\"] is essentially a map that identifies the physical altitude of the given point.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty-Tuple{OutputVar}","page":"APIs","title":"Base.isempty","text":"isempty(var::OutputVar)\n\nDetermine whether an OutputVar is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.short_name","page":"APIs","title":"ClimaAnalysis.Var.short_name","text":"short_name(var::OutputVar)\n\nReturn the short_name of the given var, if available.\n\nIf not available, return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.long_name","page":"APIs","title":"ClimaAnalysis.Var.long_name","text":"long_name(var::OutputVar)\n\nReturn the long_name of the given var, if available.\n\nIf not available, return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.units","page":"APIs","title":"ClimaAnalysis.Var.units","text":"units(var::OutputVar)\n\nReturn the units of the given var, if available.\n\nIf not available, return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_units","page":"APIs","title":"ClimaAnalysis.Var.has_units","text":"has_units(var::OutputVar)\n\nReturn whether the given var has units or not.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.remake","page":"APIs","title":"ClimaAnalysis.Var.remake","text":"remake(var; attributes, dims, dim_attributes, data)\n\nRemake an OutputVar. If a keyword argument is not supplied, then it defaults to attributes, dims, dim_attributes, or data of var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.slice","page":"APIs","title":"ClimaAnalysis.Var.slice","text":"slice(var::OutputVar, by = NearestValue(), kwargs...)\n\nReturn a new OutputVar by slicing across dimensions as defined by the keyword arguments.\n\nWhen a time dimension is selected and start_date is among var's attributes, it is possible to directly pass a Dates.DateTime and slice will automatically convert it into the corresponding time.\n\nThe keyword argument by can be ClimaAnalysis.NearestValue(), ClimaAnalysis.MatchValue(), or ClimaAnalysis.Index().\n\nNearestValue(): The nearest value will be selected for slicing.\nMatchValue(): The approximately matched value will be selected for slicing.\nIndex(): The index passed in will be used for slicing.\n\nExample\n\nslice(var, lat = 30, lon = 20, time = 100)\n\nIf var has start_date among its attributes.\n\nimport Dates\nslice(var, lat = 30, lon = 20, time = Dates.DateTime(2020, 12, 21))\n\ncompat: Support for Dates and generalized dimension names\nCalling slice with a DateTime and specifying a dimension by one of its name (instead of the actual name in the file) was introduced in ClimaAnalysis v0.5.17.\n\ncompat: Support for AbstractSelector\nCalling slice with the by keyword argument was introduced after ClimaAnalysis v0.5.18.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_lat","page":"APIs","title":"ClimaAnalysis.Var.average_lat","text":"average_lat(var::OutputVar; ignore_nan = true, weighted = false)\n\nReturn a new OutputVar where the values on the latitudes are averaged arithmetically.\n\nWhen weighted is true, weight the average over cos(lat).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.weighted_average_lat","page":"APIs","title":"ClimaAnalysis.Var.weighted_average_lat","text":"weighted_average_lat(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values on the latitudes are averaged arithmetically with weights of cos(lat).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_lon","page":"APIs","title":"ClimaAnalysis.Var.average_lon","text":"average_lon(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values on the longitudes are averaged arithmetically.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_lonlat","page":"APIs","title":"ClimaAnalysis.Var.average_lonlat","text":"average_lonlat(var; ignore_nan = true)\n\nReturn a new OutputVar where the values along the longitude and latitude dimensions are averaged arithmetically.\n\nnote: Difference from average_lon and average_lat\nThe computation average_lon(average_lat(var)) computes an average of averages. This function computes the global average over all the values across both the longitude and latitude dimensions. In particular, the results will differ when there are NaNs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.weighted_average_lonlat","page":"APIs","title":"ClimaAnalysis.Var.weighted_average_lonlat","text":"weighted_average_lonlat(var; ignore_nan = true)\n\nReturn a new OutputVar where the values along the longitude and latitude dimensions are averaged arithmetically with weights of cos(lat) along the latitude dimension.\n\nnote: Difference from average_lon and weighted_average_lat\nThe computation average_lon(weighted_average_lat(var)) computes an average of averages. This function computes the global latitude-weighted average over all the values across both the longitude and latitude dimensions. In particular, the results differ when there are NaNs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_x","page":"APIs","title":"ClimaAnalysis.Var.average_x","text":"average_x(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values along the x dimension are averaged arithmetically.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_y","page":"APIs","title":"ClimaAnalysis.Var.average_y","text":"average_y(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values along the y dimension are averaged arithmetically.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_xy","page":"APIs","title":"ClimaAnalysis.Var.average_xy","text":"average_xy(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values along both horizontal dimensions x and y are averaged arithmetically.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.average_time","page":"APIs","title":"ClimaAnalysis.Var.average_time","text":"average_time(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the values are averaged arithmetically in time.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.variance_lon","page":"APIs","title":"ClimaAnalysis.Var.variance_lon","text":"variance_lon(var; ignore_nan = true)\n\nReturn a new OutputVar where the values are the variances along the longitude dimension.\n\nIf corrected is true, then the variance is computed by dividing the sample mean by n - 1, whereas if corrected is false, then the variance is computed by dividing the sample mean by n, where n is the number of elements that the variance is being computed over.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.variance_lat","page":"APIs","title":"ClimaAnalysis.Var.variance_lat","text":"variance_lat(var; ignore_nan = true, corrected = true)\n\nReturn a new OutputVar where the values are the variances along the latitude dimension.\n\nIf corrected is true, then the variance is computed by dividing the sample mean by n - 1, whereas if corrected is false, then the variance is computed by dividing the sample mean by n, where n is the number of elements that the variance is being computed over.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.variance_time","page":"APIs","title":"ClimaAnalysis.Var.variance_time","text":"variance_time(var; ignore_nan = true)\n\nReturn a new OutputVar where the values are the variances along the time dimension.\n\nIf corrected is true, then the variance is computed by dividing the sample mean by n - 1, whereas if corrected is false, then the variance is computed by dividing the sample mean by n, where n is the number of elements that the variance is being computed over.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.window","page":"APIs","title":"ClimaAnalysis.Var.window","text":"window(var::OutputVar, dim_name; left = nothing, right = nothing, by = NearestValue())\n\nReturn a new OutputVar by selecting the values of the given dimension that are between left and right.\n\nIf left and/or right are nothing, assume beginning (or end) of the array.\n\nFor the time dimension, left and right can also be Dates.DateTime (if var contains a start_date).\n\nThe keyword argument by can be ClimaAnalysis.NearestValue(), ClimaAnalysis.MatchValue(), or ClimaAnalysis.Index().\n\nNearestValue(): The nearest value will be selected for windowing.\nMatchValue(): The approximately matched value will be selected for windowing.\nIndex(): The index passed in will be used for windowing.\n\nExample\n\nwindow(var, 'lat', left = -50, right = 50)\nwindow(var, 'time', left = DateTime(2008), right = DateTime(2009))\n\ncompat: Support for Dates and generalized dimension names\nCalling window with a DateTime and specifying a dimension by one of its name (instead of the actual name in the file) was introduced in ClimaAnalysis v0.5.17.\n\ncompat: Support for AbstractSelector\nCalling window with the by keyword argument was introduced after ClimaAnalysis v0.5.18.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.arecompatible","page":"APIs","title":"ClimaAnalysis.Var.arecompatible","text":"arecompatible(x::OutputVar, y::OutputVar)\n\nReturn whether two OutputVar are defined on the same physical space\n\nThis is accomplished by comparing dims and dim_attributes (the latter because they might contain information about the units).\n\nWe assume that:\n\ndim2index and index2dim where correctly created and they reflect dims\ndata is also consistent with dims,\n\nWe also do not check units for data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.shift_longitude","page":"APIs","title":"ClimaAnalysis.Var.shift_longitude","text":"shift_longitude(var, lower_lon, upper_lon; shift_by = 0.0)\n\nShift the longitudes in var to lower_lon to upper_lon degrees.\n\nWe assume that the units of the longitude dimension is degrees. If this is not the case, then one can use convert_dim_units to convert the units to degrees.\n\nThis function assumes the prime meridian (0th degree) in var is the same before and after shifting the longitudes.\n\nIf two points share the same longitude (e.g. -180 degrees and 180 degrees on longitudes spanning from -180 degrees to 180 degrees), then we remove the last longitude before shifting the longitudes. This is necessary to prevent duplicated longitudes after shifting longitudes.\n\nTo shift from -180 to 180 degrees to 0 to 360 degrees, use shift_longitude(var, 0.0, 360.0) and to shift from 0 to 360 degrees to -180 to 180 degrees, use shift_longitude(var, -180.0, 180.0).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.center_longitude!","page":"APIs","title":"ClimaAnalysis.Var.center_longitude!","text":"center_longitude!(var::OutputVar, lon::Real)\n\nShift the longitudes in var so that lon is the center one.\n\nThis is useful to center the global projection to the 180 meridian instead of the 0.\n\nwarn: Deprecated\nThis function is deprecated and users are encouraged to use shift_longitude instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.times","page":"APIs","title":"ClimaAnalysis.Var.times","text":"times(var::OutputVar)\n\nReturn the time dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.dates","page":"APIs","title":"ClimaAnalysis.Var.dates","text":"dates(var::OutputVar)\n\nReturn the date dimension in var.\n\nIf dates is a dimension, return that.\n\nIf not, try computing the dates from the start_date and the times. In this, we assume times is seconds.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.longitudes","page":"APIs","title":"ClimaAnalysis.Var.longitudes","text":"longitudes(var::OutputVar)\n\nReturn the longitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.latitudes","page":"APIs","title":"ClimaAnalysis.Var.latitudes","text":"latitudes(var::OutputVar)\n\nReturn the latitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.altitudes","page":"APIs","title":"ClimaAnalysis.Var.altitudes","text":"altitudes(var::OutputVar)\n\nReturn the altitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.pressures","page":"APIs","title":"ClimaAnalysis.Var.pressures","text":"pressures(var::OutputVar)\n\nReturn the pressure dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.time_name","page":"APIs","title":"ClimaAnalysis.Var.time_name","text":"time_name(var::OutputVar)\n\nReturn the name of the time dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.date_name","page":"APIs","title":"ClimaAnalysis.Var.date_name","text":"date_name(var::OutputVar)\n\nReturn the name of the date dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.longitude_name","page":"APIs","title":"ClimaAnalysis.Var.longitude_name","text":"longitude_name(var::OutputVar)\n\nReturn the name of the longitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.latitude_name","page":"APIs","title":"ClimaAnalysis.Var.latitude_name","text":"latitude_name(var::OutputVar)\n\nReturn the name of the latitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.altitude_name","page":"APIs","title":"ClimaAnalysis.Var.altitude_name","text":"altitude_name(var::OutputVar)\n\nReturn the name of the altitude dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.pressure_name","page":"APIs","title":"ClimaAnalysis.Var.pressure_name","text":"pressure_name(var::OutputVar)\n\nReturn the name of the pressure dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_time","page":"APIs","title":"ClimaAnalysis.Var.has_time","text":"has_time(var::OutputVar)\n\nReturn whether var has a time dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_date","page":"APIs","title":"ClimaAnalysis.Var.has_date","text":"has_date(var::OutputVar)\n\nReturn whether var has a date dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_longitude","page":"APIs","title":"ClimaAnalysis.Var.has_longitude","text":"has_longitude(var::OutputVar)\n\nReturn whether var has a longitude dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_latitude","page":"APIs","title":"ClimaAnalysis.Var.has_latitude","text":"has_latitude(var::OutputVar)\n\nReturn whether var has a latitude dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_altitude","page":"APIs","title":"ClimaAnalysis.Var.has_altitude","text":"has_altitude(var::OutputVar)\n\nReturn whether var has a altitude dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.has_pressure","page":"APIs","title":"ClimaAnalysis.Var.has_pressure","text":"has_pressure(var::OutputVar)\n\nReturn whether var has a pressure dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.conventional_dim_name","page":"APIs","title":"ClimaAnalysis.Var.conventional_dim_name","text":"conventional_dim_name(dim_name::AbstractString)\n\nReturn the type of dimension as a string from longitude, latitude, time, date, altitude, or pressure if possible or dim_name as a string otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.find_corresponding_dim_name","page":"APIs","title":"ClimaAnalysis.Var.find_corresponding_dim_name","text":"find_corresponding_dim_name(dim_name::AbstractString, dim_names::Iterable)\n\nFind the corresponding dimension name in dim_names that matches dim_name.\n\nTwo names for a dimension match if both correspond to the same conventional name as determined by Var.conventional_dim_name.\n\nExample\n\njulia> ClimaAnalysis.Var.find_corresponding_dim_name(\"longitude\", [\"lat\", \"lon\"])\n\"lon\"\n\njulia> ClimaAnalysis.Var.find_corresponding_dim_name(\"time\", [\"lat\", \"lon\", \"t\"])\n\"t\"\n\njulia> ClimaAnalysis.Var.find_corresponding_dim_name(\"height\", [\"lat\", \"lon\", \"height\"])\n\"height\"\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.find_corresponding_dim_name_in_var","page":"APIs","title":"ClimaAnalysis.Var.find_corresponding_dim_name_in_var","text":"find_corresponding_dim_name(dim_name::AbstractString, var)\n\nFind the corresponding dimension name in var's dimension that matches dim_name.\n\nTwo names for a dimension match if both correspond to the same conventional name as determined by Var.conventional_dim_name.\n\nIf nothing matches, return an error.\n\nThis function is useful to identify a dimension from a given name, even if it is not its conventional name (e.g., lat vs latitude).\n\nExample\n\njulia> keys(var.dims)\n(\"lon\", \"lat\", \"time\", \"potatoes\")\n\njulia> ClimaAnalysis.Var.find_corresponding_dim_name_in_var(\"t\", var)\n\"time\"\n\njulia> ClimaAnalysis.Var.find_corresponding_dim_name(\"potatoes\", var)\n\"potatoes\"\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.dim_units","page":"APIs","title":"ClimaAnalysis.Var.dim_units","text":"dim_units(var::OutputVar, dim_name)\n\nReturn the units of the given dim_name in var, if available.\n\nIf not available, return an empty string.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.range_dim","page":"APIs","title":"ClimaAnalysis.Var.range_dim","text":"range_dim(var::OutputVar, dim_name)\n\nReturn the range of the dimension dim_name in var.\n\nRange here is a tuple with the minimum and maximum of dim_name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.permutedims-Tuple{OutputVar, Any}","page":"APIs","title":"Base.permutedims","text":"permutedims(var::OutputVar, perm)\n\nPermute the dimensions of var according to perm, an iterable of dimension names specifying the permutation.\n\nThe dimension names in perm does not need to be the same as the dimensions in var. For example, dimensions with names lon and long are identified as the longitude dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.reordered_as","page":"APIs","title":"ClimaAnalysis.Var.reordered_as","text":"reordered_as(src_var::OutputVar, dest_var::OutputVar)\n\nReorder the dimensions in src_var to match the ordering of dimensions in dest_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.resampled_as","page":"APIs","title":"ClimaAnalysis.Var.resampled_as","text":"resampled_as(src_var::OutputVar, dest_var::OutputVar, dim_names = nothing)\n\nResample data in src_var to dims in dest_var.\n\nThe resampling performed here is a 1st-order linear resampling.\n\nIf the string or iterable dim_names is nothing, then resampling is done over all dimensions. Otherwise, resampling is done over the dimensions in dim_names.\n\nnote: Automatic reordering\nIf resampling is done over all dimensions, then reordering the dimensions of the resulting OutputVar is automatically done.\n\nThe correct dimension to resample on is identified by using conventional_dim_name. For example, if src_var has a longitude dimension named lon, dest_var has a longitude dimension named long, and dim_names is longitude, then resampling is done on the longitude dimension because conventional_dim_name maps lon, long, and longitude to longitude.\n\ncompat: `dim_names` keyword argument\nThe keyword argument dim_names is introduced in ClimaAnalysis v0.5.14.\n\n\n\n\n\nresampled_as(src_var::OutputVar, kwargs...)\n\nResample data in src_var to dimensions as defined by the keyword arguments.\n\nThe resampling performed here is a 1st-order linear resampling.\n\nFor example, to resample on the longitude dimension of [0.0, 1.0, 2.0], one can do resampled_as(src_var, lon = [0.0, 1.0, 2.0]).\n\nIf the dimensions in dims and src_var.dims match (ignoring order), the resulting OutputVar will have its dimensions reordered to match the order in dims. Otherwise, the dimensions of the resulting OutputVar will remain unchanged. If the dimensions of dims is a strict subset of the dimensions in src_var, then partial resampling is done instead.\n\nNote that there is no checking for units of the dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.convert_units","page":"APIs","title":"ClimaAnalysis.Var.convert_units","text":"Var.convert_units(var, new_units; conversion_function = nothing)\n\nReturn a new OutputVar with converted physical units of var to new_units, if possible.\n\nAutomatic conversion happens when the units for var and new_units are both parseable. When var does not have units (see also Var.has_units) or has no parseable units, a conversion function conversion_function is required.\n\nconversion_function has to be a function that takes one data point and returns the transformed value.\n\nBeing parseable means that Unitful.uparse can parse the expression. Please, refer to the documentation for Unitful.jl for more information.\n\nExamples\n\nLet us set up a trivial 1D OutputVar with units of meters per second and automatically convert it to centimeters per second.\n\njulia> values = 0:100.0 |> collect;\n\njulia> data = copy(values);\n\njulia> attribs = Dict(\"long_name\" => \"speed\", \"units\" => \"m/s\");\n\njulia> dim_attribs = Dict{String, Dict}();\n\njulia> var = ClimaAnalysis.OutputVar(attribs, Dict(\"distance\" => values), dim_attribs, data);\n\njulia> ClimaAnalysis.has_units(var)\ntrue\n\njulia> var_cms = ClimaAnalysis.convert_units(var, \"cm/s\");\n\njulia> extrema(var_cms.data)\n(0.0, 10000.0)\n\nNot all the units can be properly parsed, for example, assuming bob=5lol\n\njulia> attribs = Dict(\"long_name\" => \"speed\", \"units\" => \"bob/s\");\n\njulia> var_bob = ClimaAnalysis.OutputVar(attribs, Dict(\"distance\" => values), dim_attribs, data);\n\njulia> var_lols = ClimaAnalysis.convert_units(var, \"lol/s\", conversion_function = (x) -> 5x);\n\njulia> extrema(var_lols.data)\n(0.0, 500.0)\n\nFailure to specify the conversion_function will produce an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.set_units","page":"APIs","title":"ClimaAnalysis.Var.set_units","text":"set_units(var::OutputVar, units::AbstractString)\n\nSet units for data in var.\n\nwarning: Override existing units\nIf units already exist, this will override the units for data in var. To convert units, see Var.convert_units\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.convert_dim_units","page":"APIs","title":"ClimaAnalysis.Var.convert_dim_units","text":"Var.convert_dim_units(var, dim_name, new_units; conversion_function = nothing)\n\nReturn a new OutputVar with converted physical units of dim_name to new_units using conversion_function\n\nThis function does not support Unitful, so the parameter conversion_function must be supplied.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.set_dim_units!","page":"APIs","title":"ClimaAnalysis.Var.set_dim_units!","text":"set_dim_units!(var::OutputVar, dim_name::AbstractString, units::AbstractString)\n\nSet units for the dim_name dimension in var.\n\nwarning: Override existing units\nIf units already exist for the dimension, this will override the units for the dimension in var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.integrate_lonlat","page":"APIs","title":"ClimaAnalysis.Var.integrate_lonlat","text":"integrate_lonlat(var::OutputVar)\n\nIntegrate data in var on longitude and latitude with a first-order scheme. data has to be discretized on longitude and latitude.\n\nIf the points are equispaced, it is assumed that each point correspond to the midpoint of a cell which results in rectangular integration using the midpoint rule. Otherwise, the integration being done is rectangular integration using the left endpoints for integrating longitude and latitude. The units for longitude and latitude should be degrees.\n\nAll NaNs in var.data are treated as zeros when integrating.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.integrate_lat","page":"APIs","title":"ClimaAnalysis.Var.integrate_lat","text":"integrate_lat(var::OutputVar)\n\nIntegrate data in var on latitude with a first-order scheme. data has to be discretized on latitude.\n\nIf the points are equispaced, it is assumed that each point correspond to the midpoint of a cell which results in rectangular integration using the midpoint rule. Otherwise, the integration being done is rectangular integration using the left endpoints. The unit for latitude should be degrees.\n\nAll NaNs in var.data are treated as zeros when integrating.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.integrate_lon","page":"APIs","title":"ClimaAnalysis.Var.integrate_lon","text":"integrate_lon(var::OutputVar)\n\nIntegrate data in var on longitude with a first-order scheme. data has to be discretized on longitude.\n\nIf the points are equispaced, it is assumed that each point correspond to the midpoint of a cell which results in rectangular integration using the midpoint rule. Otherwise, the integration being done is rectangular integration using the left endpoints. The unit for longitude should be degrees.\n\nAll NaNs in var.data are treated as zeros when integrating.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.split_by_season-Tuple{OutputVar}","page":"APIs","title":"ClimaAnalysis.Utils.split_by_season","text":"split_by_season(var::OutputVar; seasons = (\"MAM\", \"JJA\", \"SON\", \"DJF\"))\n\nReturn a vector of four OutputVars split by season.\n\nThe months of the seasons are March to May (MAM), June to August (JJA), September to November (SON), and December to February (JDF). The order of the vector is MAM, JJA, SON, and DJF. If there are no dates found for a season, then the OutputVar for that season will be an empty OutputVar. For non-empty OutputVars, the season can be found by var.attributes[\"season\"].\n\nThe function will use the start date in var.attributes[\"start_date\"]. The unit of time is expected to be second.\n\nnote: Interpolating between seasons\nInterpolations will be inaccurate in time intervals outside of their respective season for the returned OutputVars. For example, if an OutputVar has the dates 2010-2-1, 2010-3-1, 2010-4-1, and 2011-2-1 after splitting by seasons, then any interpolation in time between the dates 2010-4-1 and 2011-2-1 will be inaccurate.\n\nThis function differs from split_by_season_across_time as split_by_season_across_time splits dates by season for each year.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Utils.split_by_season_across_time-Tuple{OutputVar}","page":"APIs","title":"ClimaAnalysis.Utils.split_by_season_across_time","text":"split_by_season_across_time(var::OutputVar)\n\nSplit var into OutputVars representing seasons, sorted in chronological order. Each OutputVar corresponds to a single season, and the ordering of the OutputVars is determined by the dates of the season. The return type is a vector of OutputVars.\n\nThe months of the seasons are March to May (MAM), June to August (JJA), September to November (SON), and December to February (DJF). If there are no dates found for a season, then the OutputVar for that season will be an empty OutputVar. The first OutputVar is guaranteed to not be empty. For non-empty OutputVars, the season can be found by var.attributes[\"season\"].\n\nAlso, for non-empty OutputVars, the year can be found by var.attributes[\"year\"]. The convention used is that the second month of the season determines the year. For example, the year of DJF is the same year as Janauary.\n\nThe function will use the start date in var.attributes[\"start_date\"]. The unit of time is expected to be second.\n\nThis function differs from split_by_season as split_by_season splits dates by season and ignores that seasons can come from different years.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.average_season_across_time","page":"APIs","title":"ClimaAnalysis.Var.average_season_across_time","text":"average_season_across_time(var::OutputVar; ignore_nan = true)\n\nReturn a new OutputVar where the seasons are averaged arithmetically in time.\n\nThe values of time dimension of var correspond to the first date for the season.\n\nThe months of the seasons are March to May (MAM), June to August (JJA), September to November (SON), and December to February (DJF). If there are no dates found for a season, then the season is skipped. The season can be found by var.attributes[\"season\"], which returns a vector of season names.\n\nThe year can be found by var.attributes[\"year\"], which returns a vector of years as strings. The convention used is that the second month of the season determines the year. For example, the year of DJF is the same year as Janauary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.split_by_month-Tuple{OutputVar}","page":"APIs","title":"ClimaAnalysis.Utils.split_by_month","text":"split_by_month(var::OutputVar)\n\nSplit var into OutputVars representing months, sorted in chronological order. Each OutputVar corresponds to a single month, and the ordering of the OutputVars is determined by the dates of the month. The return type is a vector of OutputVars.\n\nIf there are no dates found for a month, then the OutputVar for that season will be an empty OutputVar. For non-empty OutputVars, the month can be found by var.attributes[\"month\"].\n\nThe function will use the start date in var.attributes[\"start_date\"]. The unit of time is expected to be second.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.bias","page":"APIs","title":"ClimaAnalysis.Var.bias","text":"bias(sim::OutputVar, obs::OutputVar; mask = nothing)\n\nReturn a OutputVar whose data is the bias (sim.data - obs.data) and compute the global bias of data in sim and obs over longitude and latitude. The result is stored in var.attributes[\"global_bias\"].\n\nThis function is currently implemented for OutputVars with only the dimensions longitude and latitude. Units must be supplied for data and dimensions in sim and obs. The units for longitude and latitude should be degrees. Resampling is done automatically by resampling obs on sim. Attributes in sim and obs will be thrown away. The long name and short name of the returned OutputVar will be updated to reflect that a bias is computed.\n\nThe parameter mask is a function that masks a OutputVar. See apply_landmask and apply_oceanmask.\n\nSee also global_bias, squared_error, global_mse, global_rmse.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.global_bias","page":"APIs","title":"ClimaAnalysis.Var.global_bias","text":"global_bias(sim::OutputVar, obs::OutputVar; mask = nothing)\n\nReturn the global bias of data in sim and obs over longitude and latitude.\n\nThis function is currently only implemented for OutputVars with only the dimensions longitude and latitude. Units must be supplied for data and dimensions in sim and obs. The units for longitude and latitude should be degrees. Resampling is done automatically by resampling obs on sim.\n\nThe parameter mask is a function that masks a OutputVar. See apply_landmask and apply_oceanmask.\n\nSee also bias, squared_error, global_mse, global_rmse.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.squared_error","page":"APIs","title":"ClimaAnalysis.Var.squared_error","text":"squared_error(sim::OutputVar, obs::OutputVar; mask = nothing)\n\nReturn a OutputVar whose data is the squared error ((sim.data - obs.data)^2) and compute the global mean squared error (MSE) and global root mean squared error (RMSE) of data in sim and obs over longitude and latitude. The result is stored in var.attributes[\"global_mse\"] and var.attributes[\"global_rmse\"].\n\nThis function is currently implemented for OutputVars with only the dimensions longitude and latitude. Units must be supplied for data and dimensions in sim and obs. The units for longitude and latitude should be degrees. Resampling is done automatically by resampling obs on sim. Attributes in sim and obs will be thrown away. The long name and short name of the returned OutputVar will be updated to reflect that a squared error is computed.\n\nThe parameter mask is a function that masks a OutputVar. See apply_landmask and apply_oceanmask.\n\nSee also global_mse, global_rmse, bias, global_bias.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.global_mse","page":"APIs","title":"ClimaAnalysis.Var.global_mse","text":"global_mse(sim::OutputVar, obs::OutputVar; mask = nothing)\n\nReturn the global mean squared error (MSE) of data in sim and obs over longitude and latitude.\n\nThis function is currently implemented for OutputVars with only the dimensions longitude and latitude. Units must be supplied for data and dimensions in sim and obs. The units for longitude and latitude should be degrees. Resampling is done automatically by resampling obs on sim.\n\nThe parameter mask is a function that masks a OutputVar. See apply_landmask and apply_oceanmask.\n\nSee also squared_error, global_rmse, bias, global_bias.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.global_rmse","page":"APIs","title":"ClimaAnalysis.Var.global_rmse","text":"global_rmse(sim::OutputVar, obs::OutputVar; mask = nothing)\n\nReturn the global root mean squared error (RMSE) of data in sim and obs over longitude and latitude.\n\nThis function is currently implemented for OutputVars with only the dimensions longitude and latitude. Units must be supplied for data and dimensions in sim and obs. The units for longitude and latitude should be degrees. Resampling is done automatically by resampling obs on sim.\n\nThe parameter mask is a function that masks a OutputVar. See apply_landmask and apply_oceanmask.\n\nSee also squared_error, global_mse, bias, global_bias.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.shift_to_start_of_previous_month","page":"APIs","title":"ClimaAnalysis.Var.shift_to_start_of_previous_month","text":"shift_to_start_of_previous_month(var::OutputVar)\n\nShift the times in the time dimension to the start of the previous month.\n\nAfter applying this function, the start date in the attributes correspond to the first element in the time array.\n\nThis function is helpful in ensuring consistency in dates between simulation and observational data. One example of this is when adjusting monthly averaged data. For instance, suppose that data on 2010-02-01 in the OutputVar corresponds to the monthly average for January. This function shifts the times so that 2010-01-01 will correspond to the monthly average for January.\n\nNote that this function only works for the time dimension and will not work for the date dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.LonLatMask","page":"APIs","title":"ClimaAnalysis.Var.LonLatMask","text":"Representing a mask that can be applied to a `OutputVar`.\n\nLonLatMask is a struct that is callable. If mask is a LonLatMask, you can apply the mask by doing mask(var), where var is a OutputVar.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.apply_landmask","page":"APIs","title":"ClimaAnalysis.Var.apply_landmask","text":"apply_landmask(var::OutputVar; threshold = 0.5)\n\nApply a land mask to var by NaNing any data whose coordinates are located on land.\n\nnote: Threshold keyword argument\nThe threshold keyword argument is available in ClimaAnalysis v0.5.19 and beyond.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.apply_oceanmask","page":"APIs","title":"ClimaAnalysis.Var.apply_oceanmask","text":"apply_oceanmask(var::OutputVar; threshold = 0.5)\n\nApply an ocean mask to var by NaNing any data whose coordinates are in the ocean.\n\nnote: Threshold keyword argument\nThe threshold keyword argument is available in ClimaAnalysis v0.5.18 and beyond.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.generate_lonlat_mask","page":"APIs","title":"ClimaAnalysis.Var.generate_lonlat_mask","text":"generate_lonlat_mask(var::OutputVar, zero_to, one_to; threshold = 0.5)\n\nReturns a masking function that takes an OutputVar and masks its data using var.data, which contains only zeros and ones.\n\nThe data in var is resampled to match the dimensions of the OutputVar. After resampling, values greater than or equal to threshold are rounded to one and all other values are rounded to zero. Zeros are replaced with zero_to, and ones are replaced with one_to. The masking is applied as element wise multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.generate_land_mask","page":"APIs","title":"ClimaAnalysis.Var.generate_land_mask","text":"generate_land_mask(land, ocean; threshold = 0.5)\n\nGenerate a land mask, where values on the land are multiplied by land and values on the ocean are multipled by ocean.\n\nThe land mask is a binary mask, where zeros represent the land and ones represent the ocean.\n\nSee ClimaAnalysis.Var.generate_lonlat_mask for more information about the masking procedure.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.generate_ocean_mask","page":"APIs","title":"ClimaAnalysis.Var.generate_ocean_mask","text":"generate_ocean_mask(ocean, land; threshold = 0.5)\n\nGenerate an ocean mask, where values on the land are multiplied by land and values on the ocean are multipled by ocean.\n\nThe ocean mask is a binary mask, where zeros represent the ocean and ones represent the land.\n\nSee ClimaAnalysis.Var.generate_lonlat_mask for more information about the masking procedure.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.make_lonlat_mask","page":"APIs","title":"ClimaAnalysis.Var.make_lonlat_mask","text":"make_lonlat_mask(var;\n                 set_to_val = nothing,\n                 true_val = NaN,\n                 false_val = 1.0)\n\nReturn a masking function that takes in a OutputVar and mask the data using var.data.\n\nThe parameter set_to_val is a function that takes in an element of var.data and return true or false. If set_to_val returns true, then the value will be true_val in the mask and if set_to_nan returns false, then the value will be false_val in the mask.\n\nIf set_to_val is nothing, then no transformation is done and var.data is used. This is helpful if var.data is already an array of NaNs and ones or an array of zeros and ones.\n\nwarning: Deprecated\nThis function is deprecated and users are encouraged to use generate_lonlat_mask instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.replace-Tuple{OutputVar, Vararg{Pair}}","page":"APIs","title":"Base.replace","text":"replace(var::OutputVar, old_new::Pair...)\n\nReturn a OutputVar where, for each pair old  => new, all occurences of old are replaced by new in var.data\n\nThis function is useful if there are NaNs or missing values in the data. For instance, you want to use the ocean mask, but there are NaNs in the ocean. You can replace all the NaN and missing values with 0.0 and apply the ocean mask afterward.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace-Tuple{Union{Function, Type}, OutputVar}","page":"APIs","title":"Base.replace","text":"replace!(new::Union{Function, Type}, var::OutputVar; [count::Integer])\n\nReturn a new OutputVar where each value ofvar.datais replaced bynew(x). Ifcountis specified, then replace at mostcount` values in total.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace!-Tuple{OutputVar, Vararg{Pair}}","page":"APIs","title":"Base.replace!","text":"replace!(var::OutputVar, old_new::Pair...; [count::Integer])\n\nFor each pair old  => new, all occurences of old are replaced by new in var.data. See replace.\n\nThis function is useful if there are NaNs or missing values in the data. For instance, you want to use the ocean mask, but there are NaNs in the ocean. You can replace all the NaN and missing values with 0.0 and apply the ocean mask afterward.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace!-Tuple{Union{Function, Type}, OutputVar}","page":"APIs","title":"Base.replace!","text":"replace!(new::Union{Function, Type}, var::OutputVar; [count::Integer])\n\nReturn each value of var.data by new(x). If count is specified, then replace at most count values in total.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.cat-Tuple{Vararg{OutputVar}}","page":"APIs","title":"Base.cat","text":"Base.cat(vars::OutputVar...; dims::String)\n\nConcatenate vars along the dimension dims.\n\nThis function is helpful if you need to concatenate OutputVars after applying split_by_season_across_time or window.\n\nThis function does not support concatenating OutputVars of different quantities as determined by the short_name.\n\nAttributes that are not start_date, short_name, or \"units\" are discarded in the process.\n\nNote that concatenation along multiple dimensions is not possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.reverse_dim","page":"APIs","title":"ClimaAnalysis.Var.reverse_dim","text":"reverse_dim(var::OutputVar, dim_name)\n\nReverse a dimension by name.\n\nThis function is helpful if the order of a dimension need to be reversed, so that an interpolant can be made.\n\nSee also in-place reverse_dim!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.reverse_dim!","page":"APIs","title":"ClimaAnalysis.Var.reverse_dim!","text":"reverse_dim!(var::OutputVar, dim_name)\n\nLike reverse_dim, but operates in-place in var.\n\nThis function is helpful if the order of a dimension need to be reversed, so that an interpolant can be made.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.show-Tuple{IO, OutputVar}","page":"APIs","title":"Base.show","text":"Base.show(io::IO, var::OutputVar)\n\nPretty print the contents of an OutputVar.\n\nPrint the attributes, dimension attributes, and dimensions that the data is defined over.\n\n\n\n\n\n","category":"method"},{"location":"api/#Selectors","page":"APIs","title":"Selectors","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Var.AbstractSelector","page":"APIs","title":"ClimaAnalysis.Var.AbstractSelector","text":"AbstractSelector\n\nAn object that determines which indices are selected.\n\nAbstractSelectors have to provide one function, get_index\n\nThe function has to have the signature get_index(var, dim_name, idx_or_val, ::AbstractSelector) and return a single index. You can assume that dim_name is in keys(var.dims).\n\nThe function get_index is used by slice and window. For instance, if you use ClimaAnalysis.slice(var, time = 2), then dim_name is time, and idx_or_val is 2.\n\nFor example, to implement an AbstractSelector that always take the first index of the dimension regardless of the value or index passed in, you can write the following:\n\nstruct FirstIndex <: ClimaAnalysis.AbstractSelector end\n\nfunction ClimaAnalysis.get_index(var, dim_name, idx_or_val, ::FirstIndex)\n    return 1\nend\n\n# Get the first time slice of var. The parameter 10 does not do anything.\nClimaAnalysis.slice(var, time = 10, by = FirstIndex())\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.NearestValue","page":"APIs","title":"ClimaAnalysis.Var.NearestValue","text":"NearestValue\n\nGet the index of the nearest value.\n\nIf the dimension is not one dimesional, then an error is thrown.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.MatchValue","page":"APIs","title":"ClimaAnalysis.Var.MatchValue","text":"MatchValue\n\nGet the index of the approximately matched value.\n\nIf the value does not exist, or the dimension is not one-dimensional, then an error is thrown.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.Index","page":"APIs","title":"ClimaAnalysis.Var.Index","text":"Index\n\nSelect the index in the dimension.\n\nIf the index is out of bounds, then an error is thrown.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.get_index-Tuple{Any, Any, Any, NearestValue}","page":"APIs","title":"ClimaAnalysis.Var.get_index","text":"get_index(var, dim_name, val, ::NearestValue)\n\nGet the index corresponding to the nearest value to val in the dim_name dimension.\n\nThis function assumes that dim_name exists in var, and the dim_name dimension is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.get_index-Tuple{Any, Any, Any, MatchValue}","page":"APIs","title":"ClimaAnalysis.Var.get_index","text":"get_index(var, dim_name, val, ::MatchValue)\n\nGet the index that approximately match with val in the dim_name dimension.\n\nIf a val is not in the dim_name dimension, then an error is thrown.\n\nThis function assumes that dim_name exists in var, and the dim_name dimension is one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Var.get_index-Tuple{Any, Any, Any, Index}","page":"APIs","title":"ClimaAnalysis.Var.get_index","text":"get_index(var, dim_name, idx, ::Index)\n\nGet the index idx.\n\nIf idx is out of bounds, then an error is thrown.\n\nThis function assumes that dim_name exists in var.\n\n\n\n\n\n","category":"method"},{"location":"api/#FlatVar","page":"APIs","title":"FlatVar","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Var.Metadata","page":"APIs","title":"ClimaAnalysis.Var.Metadata","text":"Representing the metadata of an `OutputVar` and contain all the necessary\ninformation to reconstruct an `OutputVar`.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.FlatVar","page":"APIs","title":"ClimaAnalysis.Var.FlatVar","text":"Representing a flat output variable\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Var.flatten","page":"APIs","title":"ClimaAnalysis.Var.flatten","text":"flatten(var::OutputVar;\n        dims = (\"longitude\", \"latitude\", \"pressure_level\", \"z\", \"time\"),\n        ignore_nan = true,\n        mask = nothing)\n\nFlatten var into a FlatVar according to the ordering dims.\n\nThe default order of dimensions for flattening is (\"longitude\", \"latitude\", \"pressure_level\", \"z\", \"time\"). Dimensions not present in var are excluded from this ordering.\n\nIf ignore_nan = true, then NaNs are excluded from the flattened data. Otherwise, NaNs are included.\n\nIf mask is nothing, then values are not removed by masking. If mask is a ClimaAnalysis.LonLatMask, then values are removed according to the mask. Any value of var whose coordinates correspond to zeros on the mask are excluded from the flattened data.\n\nnote: Mask aware flatten\nThe mask keyword argument is only available for versions of ClimaAnalysis after v0.5.19.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.unflatten","page":"APIs","title":"ClimaAnalysis.Var.unflatten","text":"unflatten(var::FlatVar)\n\nUnflatten var and reconstruct the OutputVar.\n\n\n\n\n\nunflatten(metadata::Metadata, data::AbstractVector)\n\nUnflatten data according the metadata and reconstruct the OutputVar.\n\nThis function assumes that order of data before flattened is the same as flatten_dim_order(metadata).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Var.flatten_dim_order","page":"APIs","title":"ClimaAnalysis.Var.flatten_dim_order","text":"flatten_dim_order(var::FlatVar)\n\nReturn the order of the dimensions before flattening data.\n\n\n\n\n\nflatten_dim_order(metadata::Metadata)\n\nReturn the order of the dimensions before flattening data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Leaderboard","page":"APIs","title":"Leaderboard","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"Holding root mean squared errors over multiple categories and models for a single\nvariable.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{Any, Vector{String}}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name, model_names::Vector{String})\n\nConstruct a RMSEVariable with the short_name of the variable and the names of the models in model_names.\n\nThe categories default to \"ANN\", \"DJF\", \"MAM\", \"JJA\", \"SON\". The root mean square errors default to NaN. The unit for each model is missing which is denoted by an empty string.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{Any, Vector{String}, Dict}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name, model_names::Vector{String}, units::Dict)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, and provided units in the dictionary units that map model name to unit.\n\nThe categories default to \"ANN\", \"DJF\", \"MAM\", \"JJA\", \"SON\". The root mean square errors default to NaN. Any missing model in the dictionary units will has missing unit which is denoted by an empty string.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{Any, Vector{String}, Vector{String}, Dict}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name,\n             model_names::Vector{String},\n             category_names::Vector{String},\n             units::Dict)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, the categories in category_names, and provided units in the dictionary units that map model name to unit.\n\nThe root mean square errors default to NaN. Any missing model in the dictionary units will has missing unit which is denoted by an empty string.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{String, Vector{String}, Vector{String}, Any, Dict}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name::String,\n             model_names::Vector{String},\n             category_names::Vector{String},\n             RMSEs,\n             units::Dict)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, the categories in category_names, the root mean squared errors in RMSEs, and units.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{Any, Vector{String}, String}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name, model_names::Vector{String}, units::String)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, and units which map each model name to units.\n\nThe categories default to \"ANN\", \"DJF\", \"MAM\", \"JJA\", \"SON\". The root mean square errors default to NaN.\n\nThis is useful if all the models share the same unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{Any, Vector{String}, Vector{String}, String}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name,\n             model_names::Vector{String},\n             category_names::Vector{String},\n             units::String)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, the categories in category_names, and units which map each model name to units.\n\nThe root mean square errors default to NaN.\n\nThis is useful if all the models share the same unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.RMSEVariable-Tuple{String, Vector{String}, Vector{String}, Any, String}","page":"APIs","title":"ClimaAnalysis.Leaderboard.RMSEVariable","text":"RMSEVariable(short_name::String,\n             model_names::Vector{String},\n             category_names::Vector{String},\n             RMSEs,\n             units::String)\n\nConstruct a RMSEVariable with the short_name of the variable, the names of the models in model_names, the categories in category_names, the root mean squared errors in RMSEs, and units which map each model name to units.\n\nThis is useful if all the models share the same unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.model_names","page":"APIs","title":"ClimaAnalysis.Leaderboard.model_names","text":"model_names(rmse_var::RMSEVariable)\n\nReturn all the model names in rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.category_names","page":"APIs","title":"ClimaAnalysis.Leaderboard.category_names","text":"category_names(rmse_var::RMSEVariable)\n\nReturn all the category names in rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.rmse_units","page":"APIs","title":"ClimaAnalysis.Leaderboard.rmse_units","text":"rmse_units(rmse_var::RMSEVariable)\n\nReturn all the unit of the models in rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.read_rmses","page":"APIs","title":"ClimaAnalysis.Leaderboard.read_rmses","text":"read_rmses(csv_file::String, short_name::String; units = nothing)\n\nRead a CSV file and create a RMSEVariable with the short_name of the variable.\n\nThe format of the CSV file should have a header consisting of the entry \"model_name\" (or any other text as it is ignored by the function) and rest of the entries should be the category names. Each row after the header should start with the model name and the root mean squared errors for each category for that model. The entries of the CSV file should be separated by commas.\n\nThe parameter units can be a dictionary mapping model name to unit or a string. If units is a string, then units will be the same across all models. If units is nothing, then the unit is missing for each model which is denoted by an empty string.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex-Tuple{RMSEVariable, Any, Any}","page":"APIs","title":"Base.getindex","text":"Base.getindex(rmse_var::RMSEVariable, model_name, category)\n\nReturn a subset of the array holding the root mean square errors as specified by model_name and category. Support indexing by String and Int.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{RMSEVariable, String}","page":"APIs","title":"Base.getindex","text":"Base.getindex(rmse_var::RMSEVariable, model_name::String)\n\nReturn a subset of the array holding the root mean square errors as specified by model_name. Support indexing by String. Do not support linear indexing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{RMSEVariable, Any, Any, Any}","page":"APIs","title":"Base.setindex!","text":"Base.setindex!(rmse_var::RMSEVariable, rmse, model_name, category)\n\nStore a value or values from an array in the array of root mean squared errors in rmse_var. Support indexing by String and Int.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{RMSEVariable, Any, String}","page":"APIs","title":"Base.setindex!","text":"Base.setindex!(rmse_var::RMSEVariable, rmse, model_name::String)\n\nStore a value or values from an array into the array of root mean squared errors in rmse_var. Support indexing by String. Do not support linear indexing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaAnalysis.Leaderboard.add_category","page":"APIs","title":"ClimaAnalysis.Leaderboard.add_category","text":"add_category(rmse_var::RMSEVariable, categories::String...)\n\nAdd one or more categories named categories to rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.add_model","page":"APIs","title":"ClimaAnalysis.Leaderboard.add_model","text":"add_model(rmse_var::RMSEVariable, models::String...)\n\nAdd one or more models named models to rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.add_unit!","page":"APIs","title":"ClimaAnalysis.Leaderboard.add_unit!","text":"add_unit!(rmse_var::RMSEVariable, model_name, unit)\n\nAdd a unit named unit to a model named model_name in rmse_var.\n\n\n\n\n\nadd_unit!(rmse_var::RMSEVariable, model_name2unit::Dict)\n\nAdd all model name and unit pairs in the dictionary model_name2unit to rmse_var.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.find_best_single_model","page":"APIs","title":"ClimaAnalysis.Leaderboard.find_best_single_model","text":"find_best_single_model(rmse_var::RMSEVariable; category_name = \"ANN\")\n\nReturn a tuple of the best single model and the name of the model. Find the best single model using the root mean squared errors of the category category_name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.find_worst_single_model","page":"APIs","title":"ClimaAnalysis.Leaderboard.find_worst_single_model","text":"find_worst_single_model(rmse_var::RMSEVariable; category_name = \"ANN\")\n\nReturn a tuple of the worst single model and the name of the model. Find the worst single model using the root mean squared errors of the category category_name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.median","page":"APIs","title":"ClimaAnalysis.Leaderboard.median","text":"median(rmse_var::RMSEVariable)\n\nFind the median using the root mean squared errors across all categories.\n\nAny NaN is ignored in computing the median.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.reorder_categories","page":"APIs","title":"ClimaAnalysis.Leaderboard.reorder_categories","text":"reorder_categories(rmse_var::RMSEVariable, categories::Vector{String})\n\nReorder the categories in rmse_var to match categories.\n\nIf a category in categories is not present in as a category in rmse_var, then an error is thrown. This function is helpful when changing the order of the categories in the plot produced by ClimaAnalysis.Visualize.plot_boxplot!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Leaderboard.match_category_order","page":"APIs","title":"ClimaAnalysis.Leaderboard.match_category_order","text":"match_category_order(rmse_var1::RMSEVariable, rmse_var2::RMSEVariable)\n\nMake the order of categories of rmse_var_src matches the order of the categories of rmse_var_dest.\n\nThis function is helpful when changing the order of the categories in the plot produced by ClimaAnalysis.Visualize.plot_boxplot!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"APIs","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"For development and not","category":"page"},{"location":"api/#ClimaAnalysis.Utils.match_nc_filename","page":"APIs","title":"ClimaAnalysis.Utils.match_nc_filename","text":"match_nc_filename(filename::String)\n\nReturn short_name, period, reduction extracted from the filename, if matching the expected convention.\n\nThe convention is: shortname_(period)_reduction.nc, with period being optional.\n\nExamples\n\njulia> match_nc_filename(\"bob\")\n\njulia> match_nc_filename(\"ta_1d_average.nc\")\n(\"ta\", \"1d\", \"average\")\n\njulia> match_nc_filename(\"pfull_6.0m_max.nc\")\n(\"pfull\", \"6.0m\", \"max\")\n\njulia> match_nc_filename(\"hu_inst.nc\")\n(\"hu\", nothing, \"inst\")\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.squeeze","page":"APIs","title":"ClimaAnalysis.Utils.squeeze","text":"squeeze(A :: AbstractArray; dims)\n\nReturn an array that has no dimensions with size 1.\n\nWhen an iterable dims is passed, only try to squeeze the given dimensions.\n\nExamples\n\njulia> A = [[1 2] [3 4]];\n\njulia> size(A)\n(1, 4)\n\njulia> A_squeezed = squeeze(A);\n\njulia> size(A_squeezed)\n(4,)\n\njulia> A_not_squeezed = squeeze(A; dims = (2, ));\n\njulia> size(A_not_squeezed)\n(1, 4)\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.nearest_index","page":"APIs","title":"ClimaAnalysis.Utils.nearest_index","text":"nearest_index(A::AbstractArray, val)\n\nReturn the index in A closest to the given val.\n\nExamples\n\njulia> A = [-1, 0, 1, 2, 3, 4, 5];\n\njulia> nearest_index(A, 3)\n5\n\njulia> nearest_index(A, 0.1)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.kwargs","page":"APIs","title":"ClimaAnalysis.Utils.kwargs","text":"kwargs(; kwargs...)\n\nConvert keyword arguments in a dictionary that maps Symbols to values.\n\nUseful to pass keyword arguments to different constructors in a function.\n\nExamples\n\njulia> kwargs(a = 1)\npairs(::NamedTuple) with 1 entry:\n  :a => 1\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.seconds_to_prettystr","page":"APIs","title":"ClimaAnalysis.Utils.seconds_to_prettystr","text":"seconds_to_prettystr(seconds::Real)\n\nConvert the given seconds into a string with rich time information.\n\nOne year is defined as having 365 days.\n\nExamples\n\njulia> seconds_to_prettystr(10)\n\"10s\"\n\njulia> seconds_to_prettystr(600)\n\"10m\"\n\njulia> seconds_to_prettystr(86400)\n\"1d\"\n\njulia> seconds_to_prettystr(864000)\n\"10d\"\n\njulia> seconds_to_prettystr(864010)\n\"10d 10s\"\n\njulia> seconds_to_prettystr(24 * 60 * 60 * 365 + 1)\n\"1y 1s\"\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Utils.warp_string","page":"APIs","title":"ClimaAnalysis.Utils.warp_string","text":"warp_string(str::AbstractString; max_width = 70)\n\nReturn a string where each line is at most max_width characters or less or at most one word.\n\nExamples\n\njulia> warp_string(\"space\", max_width = 5)\n\"space\"\n\njulia> warp_string(\"space\", max_width = 4)\n\"space\"\n\njulia> warp_string(\"\\tspace    \", max_width = 4)\n\"space\"\n\njulia> warp_string(\"space space\", max_width = 5)\n\"space\\nspace\"\n\njulia> warp_string(\"space space\", max_width = 4)\n\"space\\nspace\"\n\njulia> warp_string(\"\\n   space  \\n  space\", max_width = 4)\n\"space\\nspace\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Atmos","page":"APIs","title":"Atmos","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Atmos","page":"APIs","title":"ClimaAnalysis.Atmos","text":"The Atmos module contains functions that are primarily useful when working with atmospheric simulations.\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaAnalysis.Atmos.to_pressure_coordinates","page":"APIs","title":"ClimaAnalysis.Atmos.to_pressure_coordinates","text":"to_pressure_coordinates(var::OutputVar, pressure::OutputVar; target_pressure = nothing)\n\nChange the vertical dimension of var to be in pressure coordinates.\n\nIf target_pressure is nothing, the target pressure levels are computed by Plvl(z) = P0 * exp(-z / HEARTH), where HEARTH = 7000.0 and P0 = 1e5, following a simple hydrostatic model for the atmosphere.\n\ntarget_pressure can be set to a Vector to specify custom pressure levels.\n\nThe return value is a new OutputVar where the vertical dimension is pressure.\n\n:important: Values outside of the range are linearly extrapolated, so do not\n\ntrust them too much!\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Atmos.global_rmse_pfull","page":"APIs","title":"ClimaAnalysis.Atmos.global_rmse_pfull","text":"global_rmse_pfull(sim::OutputVar,\n                  obs::OutputVar;\n                  sim_pressure = nothing,\n                  obs_pressure = nothing,\n                  target_pressure = nothing)\n\nReturn the global RMSE in pressure space as a number.\n\nThe arguments sim and obs are defined as 3-dimensional OutputVars with the dimensions longitude, latitude, and altitude or pressure. If altitude is a dimension, then sim and obs are converted to pressure coordinates using to_pressure_coordinates through the keywords sim_pressure and obs_pressure. Specific pressure levels can chosen by supplying a vector of pressure levels for the keyword target_pressure.\n\nResampling is done automatically by resampling obs on sim.\n\nThe global RMSE is calculated by computing the mean squared error over longitude and latitude, integrating and normalizing over pressure, and taking the square root of the resulting number.\n\n\n\n\n\n","category":"function"},{"location":"api/#Makie","page":"APIs","title":"Makie","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Visualize.heatmap2D!","page":"APIs","title":"ClimaAnalysis.Visualize.heatmap2D!","text":"heatmap2D!(fig::Makie.Figure,\n           var::ClimaAnalysis.OutputVar;\n           p_loc = (1,1),\n           more_kwargs)\nheatmap2D!(grid_layout::Makie.GridLayout,\n           var::ClimaAnalysis.OutputVar;\n           p_loc = (1,1),\n           more_kwargs)\n\nPlot a heatmap of the given 2D variable in the given place and location. The place can be a Figure or a GridLayout.\n\nThe plot comes with labels, units, and a colorbar.\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits (also for the dimensions)\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.sliced_heatmap!","page":"APIs","title":"ClimaAnalysis.Visualize.sliced_heatmap!","text":"sliced_heatmap!(fig::Makie.Figure,\n                var::ClimaAnalysis.OutputVar,\n                cut::Union{Nothing, AbstractDict{String, <: Real}};\n                p_loc = (1,1),\n                more_kwargs,\n                )\nsliced_heatmap!(grid_layout::Makie.GridLayout,\n                var::ClimaAnalysis.OutputVar,\n                cut::Union{Nothing, AbstractDict{String, <: Real}};\n                p_loc = (1,1),\n                more_kwargs,\n                )\n\nTake a variable, slice as directed, and plot a 2D heatmap in the given place and location.\n\nThe place can be a Figure or a GridLayout.\n\nThe plot comes with labels, units, and a colorbar.\n\nArguments\n\nIf the variable is not 2D, cut has to be a dictionary that maps the dimension that has to be sliced and the value where to cut.\n\nFor example, if var has four dimensions: time, long, lat, z, this function can be used to plot a lat-long heatmap at fixed time and z. Assuming we want to plot time 100. and altitude 50., cut should be Dict(\"time\" => 100., \"z\" => 50.).\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits (also for the dimensions)\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.heatmap!","page":"APIs","title":"ClimaAnalysis.Visualize.heatmap!","text":"heatmap!(place::MakiePlace,\n         var::ClimaAnalysis.OutputVar;\n         p_loc = (1,1),\n         more_kwargs,\n         kwargs...\n        )\n\nSyntactic sugar for sliced_heatmap with kwargs instead of cut.\n\nExample\n\nheatmap!(fig, var, time = 100, lat = 70) plots a heatmap by slicing var along the time nearest to 100 and latitude nearest 70.\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.line_plot1D!","page":"APIs","title":"ClimaAnalysis.Visualize.line_plot1D!","text":"line_plot1D!(place::Makie.Figure,\n             var::ClimaAnalysis.OutputVar;\n             p_loc = (1,1),\n             more_kwargs\n             )\nline_plot1D!(place::Makie.GridLayout,\n             var::ClimaAnalysis.OutputVar;\n             p_loc = (1,1),\n             more_kwargs\n             )\n\nPlot a line plot of the given 1D variable in the given place and location. The place can be a Figure or a GridLayout.\n\nThe plot comes with labels, units.\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits (also for the dimensions)\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\nA special argument that can be passed to :axis is :dim_on_y, which puts the dimension on the y axis instead of the variable. This is useful to plot columns with z on the vertical axis instead of the horizontal one.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.sliced_line_plot!","page":"APIs","title":"ClimaAnalysis.Visualize.sliced_line_plot!","text":"sliced_line_plot!(place::Makie.Figure,\n                  var::ClimaAnalysis.OutputVar,\n                  cut::Union{Nothing, AbstractDict{String, <: Real}};\n                  p_loc = (1,1),\n                  more_kwargs\n                  )\nsliced_line_plot!(place::Makie.GridLayout,\n                  var::ClimaAnalysis.OutputVar,\n                  cut::Union{Nothing, AbstractDict{String, <: Real}};\n                  p_loc = (1,1),\n                  more_kwargs\n                  )\n\nTake a variable, slice as directed, and plot a 1D line plot in the given place and location. The place can be a Figure or a GridLayout.\n\nThe plot comes with labels, and units.\n\nArguments\n\nIf the variable is not 1D, cut has to be a dictionary that maps the dimension that has to be sliced and the value where to cut.\n\nFor example, if var has four dimensions: time, long, lat, z, this function can be used to plot a lat-long heatmap at fixed time and z. Assuming we want to plot time 100. and altitude 50., cut should be Dict(\"time\" => 100., \"z\" => 50.).\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits (also for the dimensions)\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.sliced_plot!","page":"APIs","title":"ClimaAnalysis.Visualize.sliced_plot!","text":"sliced_plot!(place::Makie.Figure,\n             var::ClimaAnalysis.OutputVar,\n             cut::Union{Nothing, AbstractDict{String, <: Real}};\n             p_loc = (1,1),\n             more_kwargs\n             )\nsliced_plot!(place::Makie.GridLayout,\n             var::ClimaAnalysis.OutputVar,\n             cut::Union{Nothing, AbstractDict{String, <: Real}};\n             p_loc = (1,1),\n             more_kwargs\n             )\n\nTake a variable, slice as directed, and plot a 1D line plot or 2D heatmap in the given place and location. The place can be a Figure or a GridLayout.\n\nThe plot comes with labels, and units (and possibly a colorbar).\n\nArguments\n\nIf the variable is not 1D/2D, cut has to be a dictionary that maps the dimension that has to be sliced and the value where to cut.\n\nFor example, if var has four dimensions: time, long, lat, z, this function can be used to plot a lat-long heatmap at fixed time and z. Assuming we want to plot time 100. and altitude 50., cut should be Dict(\"time\" => 100., \"z\" => 50.).\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits (also for the dimensions)\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.plot!","page":"APIs","title":"ClimaAnalysis.Visualize.plot!","text":"plot!(place::Makie.Figure,\n      var::ClimaAnalysis.OutputVar;\n      p_loc = (1,1),\n      more_kwargs,\n      kwargs...\n      )\nplot!(place::Makie.GridLayout,\n      var::ClimaAnalysis.OutputVar;\n      p_loc = (1,1),\n      more_kwargs,\n      kwargs...\n      )\n\nSyntactic sugar for sliced_plot with kwargs instead of cut.\n\nExample\n\nline_plot!(fig, var, time = 100, lat = 70) plots a line plot or a heatmap by slicing var along the time nearest to 100 and latitude nearest 70.\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.plot_boxplot!","page":"APIs","title":"ClimaAnalysis.Visualize.plot_boxplot!","text":"Visualize.plot_boxplot!(fig,\n                        rmse_var::ClimaAnalysis.RMSEVariable;\n                        model_names = [\"CliMA\"],\n                        ploc = (1, 1),\n                        best_and_worst_category_name = \"ANN\",\n                        legend_text_width = 10)\n\nPlot a Tukey style boxplot for each category in rmse_var.\n\nThe best and worst single models are found for the category best_and_worst_category_name and are plotted on the boxplot. When finding the best and worst single models, any models in model_names will be excluded. Additionally, any model in model_names will also be plotted on the boxplot.\n\nThe parameter ploc determines where to place the plot on the figure. The parameter legend_text_width determines the number of characters on each line in the legend.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.plot_leaderboard!","page":"APIs","title":"ClimaAnalysis.Visualize.plot_leaderboard!","text":"Visualize.plot_leaderboard!(fig,\n                            rmse_vars::ClimaAnalysis.RMSEVariable...;\n                            ploc = (1, 1),\n                            model_names = [\"CliMA\"],\n                            best_category_name = \"ANN\")\n\nPlot a heatmap over the categories and models. The models that appear is the best model as found for the category best_category_name and any other models in model_names. The root mean squared errors for each variable of interest is normalized by dividing over the median root mean squared error of each variable.\n\nThe parameter ploc determines where to place the plot on the figure.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoMakie","page":"APIs","title":"GeoMakie","text":"","category":"section"},{"location":"api/#ClimaAnalysis.Visualize.oceanmask","page":"APIs","title":"ClimaAnalysis.Visualize.oceanmask","text":"oceanmask()\n\nReturn a collection of polygons to mask out the ocean.\n\nPlot with Makie.poly.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.landmask","page":"APIs","title":"ClimaAnalysis.Visualize.landmask","text":"landmask()\n\nReturn a collection of polygons to mask out the continents.\n\nPlot with Makie.poly.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.contour2D_on_globe!","page":"APIs","title":"ClimaAnalysis.Visualize.contour2D_on_globe!","text":"contour2D_on_globe!(fig::Makie.Figure,\n                    var::ClimaAnalysis.OutputVar;\n                    p_loc = (1,1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    plot_contours = true,\n                    mask = nothing,\n                    more_kwargs)\ncontour2D_on_globe!(grid_layout::Makie.GridLayout,\n                    var::ClimaAnalysis.OutputVar;\n                    p_loc = (1,1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    plot_contours = true,\n                    mask = nothing,\n                    more_kwargs)\n\nPlot discrete contours of the given 2D variable on a projected geoid.\n\nThe plot comes with labels, units, and a colorbar.\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits\n\nThe dimensions have to be longitude and latitude.\n\nmask has to be an object that can be plotted by Makie.poly or a masking function. ClimaAnalysis comes with predefined masks, check out Visualize.oceanmask and Visualize.landmask. Also, the corresponding mask is applied to the OutputVars. For instance, using Visualize.landmask means ClimaAnalysis.apply_landmask is applied to the OutputVars when computing the bias. One can also pass in ClimaAnalysis.apply_landmask, ClimaAnalysis.apply_oceanmask, or a custom masking function (ClimaAnalysis.Var.make_lonlat_mask).\n\nnote: Passing a masking function for `mask`\nClimaAnalysis do not support mask keyword arguments for masking functions. If you want the values of the mask to not show, then pass true_val = NaN as a keyword argument to make_lonlat_mask. The color of NaN is controlled by the keyword nan_color which can be passed for the plotting function (:plot).\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\nthe coastline (:coast)\nthe mask (:mask)\n\nThe coastline is plotted from GeoMakie.coastline using the lines! plotting function.\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.heatmap2D_on_globe!","page":"APIs","title":"ClimaAnalysis.Visualize.heatmap2D_on_globe!","text":"heatmap2D_on_globe!(fig::Makie.Figure,\n                    var::ClimaAnalysis.OutputVar;\n                    p_loc = (1,1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    mask = nothing,\n                    more_kwargs)\nheatmap2D_on_globe!(grid_layout::Makie.GridLayout,\n                    var::ClimaAnalysis.OutputVar;\n                    p_loc = (1,1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    mask = nothing,\n                    more_kwargs)\n\nPlot a heatmap of the given 2D variable on a projected geoid.\n\nThe plot comes with labels, units, and a colorbar.\n\nThis function assumes that the following attributes are available:\n\nlong_name\nshort_name\nunits\n\nThe dimensions have to be longitude and latitude.\n\nmask has to be an object that can be plotted by Makie.poly or a masking function. ClimaAnalysis comes with predefined masks, check out Visualize.oceanmask and Visualize.landmask. Also, the corresponding mask is applied to the OutputVars. For instance, using Visualize.landmask means ClimaAnalysis.apply_landmask is applied to the OutputVars when computing the bias. One can also pass in ClimaAnalysis.apply_landmask, ClimaAnalysis.apply_oceanmask, or a custom masking function (ClimaAnalysis.Var.make_lonlat_mask).\n\nnote: Passing a masking function for `mask`\nClimaAnalysis do not support mask keyword arguments for masking functions. If you want the values of the mask to not show, then pass true_val = NaN as a keyword argument to make_lonlat_mask. The color of NaN is controlled by the keyword nan_color which can be passed for the plotting function (:plot).\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\nthe coastline (:coast)\nthe mask (:mask)\n\nThe coastline is plotted from GeoMakie.coastline using the lines! plotting function.\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAnalysis.Visualize.plot_bias_on_globe!","page":"APIs","title":"ClimaAnalysis.Visualize.plot_bias_on_globe!","text":"plot_bias_on_globe!(fig::Makie.Figure,\n                    sim::ClimaAnalysis.OutputVar,\n                    obs::ClimaAnalysis.OutputVar;\n                    cmap_extrema = nanextrema(ClimaAnalysis.bias(sim, obs).data),\n                    p_loc = (1, 1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    mask = nothing,\n                    more_kwargs)\nplot_bias_on_globe!(grid_layout::Makie.GridLayout,\n                    sim::ClimaAnalysis.OutputVar,\n                    obs::ClimaAnalysis.OutputVar;\n                    cmap_extrema = nanextrema(ClimaAnalysis.bias(sim, obs).data),\n                    p_loc = (1, 1),\n                    plot_coastline = true,\n                    plot_colorbar = true,\n                    mask = nothing,\n                    more_kwargs)\n\nPlot the bias (sim.data - var.data) on a projected geoid. The gloal bias and root mean squared error (RMSE) are computed and can be found in the title of the plot. This function plots the returned OutputVar of ClimaAnalysis.bias(sim, obs). See also ClimaAnalysis.bias.\n\nThe plot comes with labels, units, and a colorbar. This function uses a constrained colormap based on the values of cmap_extrema.\n\nThe dimensions have to be longitude and latitude.\n\nmask has to be an object that can be plotted by Makie.poly or a masking function. ClimaAnalysis comes with predefined masks, check out Visualize.oceanmask and Visualize.landmask. Also, the corresponding mask is applied to the OutputVars. For instance, using Visualize.landmask means ClimaAnalysis.apply_landmask is applied to the OutputVars when computing the bias. One can also pass in ClimaAnalysis.apply_landmask, ClimaAnalysis.apply_oceanmask, or a custom masking function (ClimaAnalysis.Var.make_lonlat_mask). The masking function is used for computing the bias.\n\nnote: Passing a masking function for `mask`\nClimaAnalysis do not support mask keyword arguments for masking functions. If you want the values of the mask to not show, then pass true_val = NaN as a keyword argument to make_lonlat_mask. The color of NaN is controlled by the keyword nan_color which can be passed for the plotting function (:plot).\n\nAdditional arguments to the plotting and axis functions\n\nmore_kwargs can be a dictionary that maps symbols to additional options for:\n\nthe axis (:axis)\nthe plotting function (:plot)\nthe colorbar (:cb)\nthe coastline (:coast)\nthe mask (:mask)\n\nThe coastline is plotted from GeoMakie.coastline using the lines! plotting function.\n\nThe values are splatted in the relevant functions. Populate them with a Dictionary of Symbols => values to pass additional options.\n\n\n\n\n\n","category":"function"},{"location":"visualize/#Visualizing-OutputVars","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"","category":"section"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"This page is under construction, in the meantime, consult Visualize.","category":"page"},{"location":"visualize/#Masking-part-of-the-output-in-GeoMakie","page":"Visualizing OutputVars","title":"Masking part of the output in GeoMakie","text":"","category":"section"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"When performing ocean or land simulations, it is often convenient to hide the other component (e.g., hide the ocean and focus on the continents). For GeoMakie plots, there is a direct way to accomplish this. In this section, we discuss this feature.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"The main GeoMakie plots are Visualize.contour2D_on_globe! and Visualize.heatmap2D_on_globe!. Both these functions take a mask argument. By default, mask is nothing, meaning that the entire output is displayed on the globe. Alternatively, mask can be a collection of polygons that can be plotted with Makie.poly. ClimaAnalysis comes with the most important ones Visualize.oceanmask and Visualize.landmask, to hide ocean and continents respectively.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"For example, suppose var it the variable we want to plot with a ocean mask","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"import ClimaAnalysis.Visualize: contour2D_on_globe!, oceanmask\nimport ClimaAnalysis.Utils: kwargs as ca_kwargs\nimport GeoMakie\nimport CairoMakie\n\nfig = CairoMakie.Figure()\n\ncontour2D_on_globe!(fig,\n                    var,\n                    mask = oceanmask(),\n                    more_kwargs = Dict(:mask => ca_kwargs(color = :blue)),\n                   )\n\nCairoMakie.save(\"myfigure.pdf\", fig)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"In this example, we plotted var on the globe and overplotted a blue ocean. ca_kwargs (Utils.kwargs) is a convenience function to pass keyword arguments more easily.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"The output might look something like:","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"(Image: oceanmask)","category":"page"},{"location":"visualize/#Plotting-bias","page":"Visualizing OutputVars","title":"Plotting bias","text":"","category":"section"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"After computing the bias between observational and simulation data, you may want to plot the bias and display information such as the root mean squared error (RMSE) and the global bias in the plot. To do this, you use the function plot_bias_on_globe!(fig, sim, obs). In the example below, we plot the bias between our simulation and some observations stored in ta_1d_average.nc.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"import ClimaAnalysis\nimport ClimaAnalysis.Visualize: plot_bias_on_globe!\nimport GeoMakie\nimport CairoMakie\n\nobs_var = ClimaAnalysis.OutputVar(\"ta_1d_average.nc\")\nsim_var = ClimaAnalysis.get(ClimaAnalysis.simdir(\"simulation_output\"), \"ta\")\n\nfig = CairoMakie.Figure()\nplot_bias_on_globe!(fig, sim_var, obs_var)\nCairoMakie.save(\"myfigure.pdf\", fig)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"The output produces something like:","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"(Image: biasplot)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"We can also plot the bias using an ocean mask. This also means we compute the bias only over land.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"import ClimaAnalysis\nimport ClimaAnalysis.Visualize: plot_bias_on_globe!, oceanmask\nimport GeoMakie\nimport CairoMakie\n\nobs_var = ClimaAnalysis.OutputVar(\"ta_1d_average.nc\")\nsim_var = ClimaAnalysis.get(ClimaAnalysis.simdir(\"simulation_output\"), \"ta\")\n\nfig = CairoMakie.Figure()\nplot_bias_on_globe!(fig,\n                    var,\n                    mask = oceanmask(),\n                    more_kwargs = Dict(:mask => ca_kwargs(color = :blue)),\n                   )\nCairoMakie.save(\"myfigure.pdf\", fig)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"The output produces something like:","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"(Image: biasplot_oceanmask)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"We can also plot the bias using a custom mask generated from make_lonlat_mask.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"note: Passing a masking function for `mask`\nClimaAnalysis do not support mask keyword arguments for masking functions. If you want the values of the mask to not show in a plot, then pass true_val = NaN as a keyword argument to make_lonlat_mask. The color of NaN is controlled by the keyword nan_color which can be passed for the plotting function (:plot).Note that if the backend is CairoMakie, then the keyword nan_color does nothing. See this issue.","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"import ClimaAnalysis\nimport ClimaAnalysis.Visualize: plot_bias_on_globe!, oceanmask\nimport GeoMakie\nimport CairoMakie\n\nmask_var = ClimaAnalysis.OutputVar(\"ocean_mask.nc\")\nmask_fn = ClimaAnalysis.generate_lonlat_mask(mask_var, NaN, 1.0)\n\nobs_var = ClimaAnalysis.OutputVar(\"ta_1d_average.nc\")\nsim_var = ClimaAnalysis.get(ClimaAnalysis.simdir(\"simulation_output\"), \"ta\")\n\nfig = CairoMakie.Figure()\nplot_bias_on_globe!(fig, var, mask = mask_fn)\nCairoMakie.save(\"myfigure.pdf\", fig)","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"The output produces something like:","category":"page"},{"location":"visualize/","page":"Visualizing OutputVars","title":"Visualizing OutputVars","text":"(Image: bias_with_custom_mask_plot)","category":"page"},{"location":"rmse_var/#RMSEVariables","page":"RMSEVariables","title":"RMSEVariables","text":"","category":"section"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"RMSEVariables contain all the information needed to process and compare root mean squared errors (RMSEs) between different models and categories (e.g., seasons) for a single variable of interest.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"ClimaAnalysis provides several constructors for making a RMSEVariable. For all constructors, a short name and a vector of model names must be provided. If units are not provided, then each model will have no unit which denotes the missing unit. See the examples below where the constructor can take in a short name, a vector of model names, a vector of categories, and a dictionary mapping model names to units or a string of the name of the unit.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"import ClimaAnalysis\n\nrmse_var = ClimaAnalysis.RMSEVariable(\"ta\", [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"])\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    Dict(\"ACCESS-CM2\" => \"K\", \"ACCESS-ESM1-5\" => \"K\"),\n)\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    [\"DJF\", \"MAM\", \"JJA\", \"SON\", \"ANN\"],\n    Dict(\"ACCESS-CM2\" => \"K\", \"ACCESS-ESM1-5\" => \"K\"),\n)\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    [\"DJF\", \"MAM\", \"JJA\", \"SON\", \"ANN\"],\n    ones(2, 5),\n    Dict(\"ACCESS-CM2\" => \"K\", \"ACCESS-ESM1-5\" => \"K\"),\n)\n# Convenience functions if models all share the same unit\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    \"K\",\n)\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    [\"DJF\", \"MAM\", \"JJA\", \"SON\", \"ANN\"],\n    \"K\",\n)\nrmse_var = ClimaAnalysis.RMSEVariable(\n    \"ta\",\n    [\"ACCESS-CM2\", \"ACCESS-ESM1-5\"],\n    [\"DJF\", \"MAM\", \"JJA\", \"SON\", \"ANN\"],\n    ones(2, 5),\n    \"K\",\n)\n\nnothing # hide","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"The RMSEVariable can be inspected using model_names, category_names, and rmse_units which provide the model names, the category names, and the units respectively.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"ClimaAnalysis.model_names(rmse_var)\nClimaAnalysis.category_names(rmse_var)\nClimaAnalysis.rmse_units(rmse_var)","category":"page"},{"location":"rmse_var/#Reading-RMSEs-from-CSV-file","page":"RMSEVariables","title":"Reading RMSEs from CSV file","text":"","category":"section"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"Typically, the root mean squared errors (RMSEs) of different models across different categories are stored in a different file and need to be loaded in. ClimaAnalysis can load this information from a CSV file and store it in a RMSEVariable. The format of the CSV file should have a header consisting of the entry \"model_name\" (or any other text as it is ignored by the function) and rest of the entries should be the category names. Each row after the header should start with the model name and the root mean squared errors for each category for that model. The entries of the CSV file should be separated by commas.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"See the example below using read_rmses where data is loaded from test_csv.csv and a short name of ta is provided. One can also pass in a dictionary mapping model names to units for units or a string if the units are the same for all the models.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"rmse_var = ClimaAnalysis.read_rmses(\"./data/test_csv.csv\", \"ta\")\nrmse_var = ClimaAnalysis.read_rmses(\n    \"./data/test_csv.csv\",\n    \"ta\",\n    units = Dict(\"ACCESS-CM2\" => \"K\", \"ACCESS-ESM1-5\" => \"K\"), # passing units as a dictionary\n)\nrmse_var = ClimaAnalysis.read_rmses(\n    \"./data/test_csv.csv\",\n    \"ta\",\n    units = \"K\", # passing units as a string\n)\n\nnothing # hide","category":"page"},{"location":"rmse_var/#Indexing","page":"RMSEVariables","title":"Indexing","text":"","category":"section"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"After loading the data, one may want to inspect, change, or manipulate the data. This is possible by the indexing functionality that RMSEVariable provides. Indexing into a RMSEVariable is similar, but not the same as indexing into an array. Indexing by integer or string is supported, but linear indexing (e.g. rmse_var[1]) is not supported. integer or string is supported, but linear indexing (e.g., rmse_var[1]) is not supported.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"rmse_var[:, :]\nrmse_var[\"ACCESS-CM2\"]\nrmse_var[:, \"MAM\"]\nrmse_var[\"ACCESS-CM2\", [\"ANN\", \"DJF\", \"MAM\"]]\nrmse_var[2,5] = 11.2;\nrmse_var[:, :]","category":"page"},{"location":"rmse_var/#Adding-categories,-models,-and-units","page":"RMSEVariables","title":"Adding categories, models, and units","text":"","category":"section"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"It may be the case that the CSV file does not contain all the models you want to analyze, or you want to consider another category but do not want to go in and manually edit the CSV file to add it. ClimaAnalysis provides add_category, add_model, and add_unit! for adding categories, models, and units respectively. Multiple model or categories can be provided (e.g., add_model(rmse_var, \"model1\", \"model2\")) in the functions. For adding multiple units, one can pass in a dictionary mapping model names to units. See the example below using this functionality.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"rmse_var2 = ClimaAnalysis.add_category(rmse_var, \"Jan\") # can take in more than one category\nrmse_var = ClimaAnalysis.add_model(rmse_var, \"CliMA\") # can take in more than one model name\nClimaAnalysis.add_unit!(rmse_var, \"CliMA\", \"K\")\nClimaAnalysis.add_unit!(rmse_var, Dict(\"CliMA\" => \"K\")) # for adding multiple units","category":"page"},{"location":"rmse_var/#Summary-statistics","page":"RMSEVariables","title":"Summary statistics","text":"","category":"section"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"ClimaAnalysis provides several functions to compute summary statistics. As of now, ClimaAnalysis provides methods for find the best single model, the worst single model, and the median model.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"The functions find_best_single_model and find_worst_single_model default to the category \"ANN\" (corresponding to the annual mean), but any category can be considered using the parameter category_name. Furthermore, the model's root mean squared errors (RMSEs) and the model's name are returned. The function median only returns the median model's RMSEs.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"Any NaN that appears in the data is ignored when computing the summary statistics.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"See the example below using this functionality.","category":"page"},{"location":"rmse_var/","page":"RMSEVariables","title":"RMSEVariables","text":"ClimaAnalysis.find_best_single_model(rmse_var, category_name = \"DJF\")\nClimaAnalysis.find_worst_single_model(rmse_var, category_name = \"DJF\")\nClimaAnalysis.median(rmse_var)","category":"page"},{"location":"visualize_rmse_var/#Visualizing-RMSEVariables","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"","category":"section"},{"location":"visualize_rmse_var/","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"Instead of computing summary statistics, it may be more helpful to plot a box plot or a heatmap. ClimaAnalysis provides the functions plot_boxplot! and plot_leaderboard! to help visualize the root mean squared errors (RMSEs) in a RMSEVariable.","category":"page"},{"location":"visualize_rmse_var/","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"The function Visualize.plot_boxplot! makes a box plot for each category in the RMSEVariable. The best model and worst model and any other models in model_names are plotted. When finding the best and worst single models, any models in model_names will be excluded. The category to find the best and worst model defaults to \"ANN\", but can be changed using the parameter best_and_worst_category_name.","category":"page"},{"location":"visualize_rmse_var/","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"The function Visualize.plot_leaderboard! makes a heatmap of the RMSEs between the variables of interest and the categories. The best model for each variable of interest and the models in model_names are shown in the heatmap. Similar to plot_boxplot!, the category to find the best model defaults to \"ANN\", but can be changed using the parameter best_category_name. The values of the heatmap are normalized by dividing over the median model's RMSEs for each variable.","category":"page"},{"location":"visualize_rmse_var/","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"import ClimaAnalysis\nimport CairoMakie\n\n# Plot box plots\nrmse_vars = (rmse_var_ta, rmse_var_pr, rmse_var_ha)\nfig = CairoMakie.Figure(; size = (800, 300 * 3 + 400), fontsize = 20)\nfor i in 1:3\n    ClimaAnalysis.Visualize.plot_boxplot!(\n        fig,\n        rmse_vars[i],\n        ploc = (i, 1),\n        best_and_worst_category_name = \"ANN\",\n    )\nend\n\n# Plot leaderboard\nClimaAnalysis.Visualize.plot_leaderboard!(\n    fig,\n    rmse_vars...,\n    best_category_name = \"ANN\",\n    ploc = (4, 1),\n)\nCairoMakie.save(\"./assets/boxplot_and_leaderboard.png\", fig)\n\nnothing # hide","category":"page"},{"location":"visualize_rmse_var/","page":"Visualizing RMSEVariables","title":"Visualizing RMSEVariables","text":"(Image: box plot)","category":"page"},{"location":"howdoi/#How-to-guide-and-cookbook","page":"How do I?","title":"How-to guide and cookbook","text":"","category":"section"},{"location":"howdoi/#How-do-I-make-a-line-plot-with-variable-on-the-y-axis-instead-of-the-x-one?","page":"How do I?","title":"How do I make a line plot with variable on the y axis instead of the x one?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"By default, the plotting functions in MakieExt place the variable on the x axis. If you want it on the y axis instead (e.g., you are plotting the vertical profile of a column), you can pass the dim_on_y = true argument to the axis.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"For instance,","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"plot!(var, more_kwargs = Dict(:axis => [:dim_on_y => true]))","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"ClimaAnalysis.Utils provides a convenience function kwargs to specify arguments a little bit more easily without having to think about Symbols too much.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"plot!(var, more_kwargs = Dict(:axis => kwargs(dim_on_y = true))","category":"page"},{"location":"howdoi/#How-do-I-take-an-average-of-a-a-variable-in-a-given-window-of-time?","page":"How do I?","title":"How do I take an average of a a variable in a given window of time?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use the window function to select a portion of a given var. For example, to select only the time from 10 seconds to 100 for var","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"reduced_var = window(var, \"time\", left = 10, right = 100)","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"Now, you can apply the usual average functions.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"note: Did you know?\nDid you know that when you are applying window on a temporal dimension, you can also pass Dates.DateTime bounds? (E.g., left = Dates.DateTime(2008)).","category":"page"},{"location":"howdoi/#How-do-I-get-a-slice-or-window-of-a-OutputVar-by-something-other-than-the-nearest-value?","page":"How do I?","title":"How do I get a slice or window of a OutputVar by something other than the nearest value?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"With versions of ClimaAnalysis after v0.5.18, you can do this with the by keyword argument for ClimaAnalysis.slice and ClimaAnalysis.window. For example, you can do","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"ClimaAnalysis.slice(var, time = 3, by = ClimaAnalysis.Index())\nClimaAnalysis.slice(var, time = 105.0, by = ClimaAnalysis.MatchValue())\nClimaAnalysis.window(var, left = 1, right = 3, by = ClimaAnalysis.Index())\nClimaAnalysis.window(var, left = 102.0, right = 108.0, by = ClimaAnalysis.MatchValue())","category":"page"},{"location":"howdoi/#How-do-I-take-a-global-average-over-both-the-longitude-and-latitude-dimensions?","page":"How do I?","title":"How do I take a global average over both the longitude and latitude dimensions?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use average_lonlat to compute the global average over the longitude and latitude dimensions and weighted_average_lonlat to compute the global latitude-weighted average over the longitude and latitude dimensions.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"The function average_lonlat is different from composing average_lon and average_lat as the former computes an average over both the longitude and latitude dimensions and the latter computes an average of averages. In particular, the results differ when there are NaNs.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"reduced_var = average_lonlat(var)","category":"page"},{"location":"howdoi/#How-do-I-make-the-y-axis-logscale?","page":"How do I?","title":"How do I make the y axis logscale?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"The plotting routines can pass additional arguments to Makie through the more_kwargs keyword arguments. more_kwargs has to be a dictionary that maps symbols to a list of pairs. The accepted symbols are :axis, :plot, and :cb, and the pairs have to be pairs of symbols to values (the keyword arguments you want to pass down). Given that the type structure is a little complicated, ClimaAnalysis comes with a helper function for you to use. So, if you want to set the logscale for the y axis, you would do something like","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"import ClimaAnalysis.Utils: kwargs as ca_kwargs\n\nplot!(fig, var, more_kwargs = Dict(:axis => ca_kwargs(yscale = log)))","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"where inside ca_kwargs you pass the arguments you would pass to Makie.Axis.","category":"page"},{"location":"howdoi/#How-do-I-shift-my-longitudes-from-0-to-360-degrees-to-180-to-180-degrees?","page":"How do I?","title":"How do I shift my longitudes from 0 to 360 degrees to -180 to 180 degrees?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use the shift_longitude function. To shift the longitudes from 0 to 360 degrees to -180 degrees to 180 degrees, use shift_longitude(var, -180.0, 180.0). The function assumes the prime meridian (0th degree) in var is the same before and after centering the longitudes. The units of the longitude dimension should be in degrees. If this not the case, then you can use convert_dim_units to change the units of the longitude dimension to degrees.","category":"page"},{"location":"howdoi/#How-do-I-find-the-specific-name-of-a-dimension-in-a-OutputVar-given-its-conventional-name?","page":"How do I?","title":"How do I find the specific name of a dimension in a OutputVar given its conventional name?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"Suppose you want to extract the longitudes of your data but you don't know if the dimension was called lon or long. In this case, you can use the Var.longitude_name function to find the name. This function scans the names and compares them to a standard list in ClimaAnalysis.Var.LONGITUDE_NAMES. You can also customize that variable if your name is not in that list. Equivalent functions exist for others dimensions too.","category":"page"},{"location":"howdoi/#How-do-I-move-to-pressure-coordinates?","page":"How do I?","title":"How do I move to pressure coordinates?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"The Atmos module in ClimaAnalysis comes with a function, to_pressure_coordinates that does precisely that. The function takes an input OutputVar and a pressure OutputVar. If the two are compatible, a new OutputVar is returned where the values are linearly interpolated on fixed pressure levels.","category":"page"},{"location":"howdoi/#How-do-I-reorder-the-dimensions-in-a-OutputVar-to-match-the-dimensions-in-another-OutputVar-or-the-dimension-names-in-an-iterable?","page":"How do I?","title":"How do I reorder the dimensions in a OutputVar to match the dimensions in another OutputVar or the dimension names in an iterable?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use the reordered_as(src_var, dest_var) function where src_var is a OutputVar with the dimensions you want to reorder to match the dimensions in the OutputVar dest_var.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"src_var.dims |> keys |> collect\ndest_var.dims |> keys |> collect\nreordered_var = ClimaAnalysis.reordered_as(src_var, dest_var);\nreordered_var.dims |> keys |> collect","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"Alternatively, you can reorder the dimensions using permutedims.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"src_var.dims |> keys |> collect\nreordered_var = permutedims(src_var, (\"latitude\", \"lon\"));\nreordered_var.dims |> keys |> collect","category":"page"},{"location":"howdoi/#How-do-I-resample-the-data-in-a-OutputVar-using-the-dimensions-from-another-OutputVar?","page":"How do I?","title":"How do I resample the data in a OutputVar using the dimensions from another OutputVar?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use the resampled_as(src_var, dest_var) function where src_var is a OutputVar with the data you want to resample using the dimensions in another OutputVar dest_var. If resampling is possible, then a new OutputVar is returned where the data in src_var is resampled using a linear interpolation to fit the dimensions in dest_var. Resampling only over selected dimensions is possible with the keyword dim_names. Resampling is not possible when the dimensions in either OutputVars are missing units, the dimensions between the OutputVars do not agree, or the data in src_var is not defined everywhere on the dimensions in dest_var.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"src_var.data\nsrc_var.dims\ndest_var.dims\nresampled_var = ClimaAnalysis.resampled_as(src_var, dest_var);\nresampled_var.data\nresampled_var.dims # updated dims that are the same as the dims in dest_var","category":"page"},{"location":"howdoi/#How-do-I-resample-the-data-in-a-OutputVar-using-only-a-subset-of-dimensions-from-another-OutputVar?","page":"How do I?","title":"How do I resample the data in a OutputVar using only a subset of dimensions from another OutputVar?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"compat: `dim_names` keyword argument\nThe keyword argument dim_names for resampled_as is introduced in ClimaAnalysis v0.5.14.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use the dim_names keyword argument in resampled_as(src_var, dest_var) function where src_var is a OutputVar with the data you want to resample using the dimensions in another OutputVar dest_var.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"The argument dim_names can either be a string or an iterable such as an array of strings. The correct dimension is identified by using conventional_dim_name. For example, if src_var has a longitude dimension named lon, dest_var has a longitude dimension named long, and dim_names is longitude, then resampling is done on the longitude dimension because conventional_dim_name maps lon, long, and longitude to longitude.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"src_var.data\nsrc_var.dims\ndest_var.dims\npartial_resampled_var = # dim_names is either a string or an iterable\n    ClimaAnalysis.resampled_as(src_var, dest_var, dim_names = \"longitude\");\npartial_resampled_var.data\npartial_resampled_var.dims","category":"page"},{"location":"howdoi/#How-do-I-resample-without-needing-another-OutputVar?","page":"How do I?","title":"How do I resample without needing another OutputVar?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can resample by passing keyword arguments of the dimension name and the vectors to resample on. See the example below.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"src_var.data\nsrc_var.dims\nresampled_var =\n    ClimaAnalysis.resampled_as(src_var, long = [0.0, 1.0], lat = [0.0, 1.0, 2.0]);\nresampled_var.data\nresampled_var.dims","category":"page"},{"location":"howdoi/#How-do-I-load-multiple-NetCDF-files-along-the-time-dimension?","page":"How do I?","title":"How do I load multiple NetCDF files along the time dimension?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"To load multiple NetCDF files along the time dimension, you can pass in multiple NetCDF files in a vector. For example, to load \"pr1.nc\" and \"pr2.nc\" along the time dimension, you can do","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"pr_var = ClimaAnalysis.OutputVar([\"pr1.nc\", \"pr2.nc\"])","category":"page"},{"location":"howdoi/#How-do-I-concatenate-multiple-OutputVars-together?","page":"How do I?","title":"How do I concatenate multiple OutputVars together?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use cat to concatenate multiple OutputVars of the same quantity along the same dimension. See the example below of concatenating the December, January, Feburary after splitting an OutputVar into seasons across time.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"ClimaAnalysis.dates(var)\nseasons = ClimaAnalysis.split_by_season_across_time(var);\nDJF = cat(seasons[begin:4:end]..., dims = \"time\");\nClimaAnalysis.dates(DJF)","category":"page"},{"location":"howdoi/#How-do-I-apply-a-land-or-sea-mask-to-a-OutputVar?","page":"How do I?","title":"How do I apply a land or sea mask to a OutputVar?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use apply_landmask or apply_oceanmask to mask out the land or ocean, respectively, in a OutputVar. The result of apply_landmask(var) is a OutputVar, where any coordinate corresponding to land is NaN in the data. Similarly, the result of apply_oceanmask(var) is a OutputVar, where any coordinate corresponding to ocean is NaN in the data.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"var_no_land = ClimaAnalysis.apply_landmask(var)\nvar_no_ocean = ClimaAnalysis.apply_oceanmask(var)","category":"page"},{"location":"howdoi/#How-do-I-replace-NaN-and-missing-values-in-the-data-of-a-OutputVar-with-0.0?","page":"How do I?","title":"How do I replace NaN and missing values in the data of a OutputVar with 0.0?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use replace or replace! to replace all NaN and missing values in the data of a OutputVar with 0.0. See the example below of this usage.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"var_no_nan_and_missing = replace(var, missing => 0.0, NaN => 0.0)","category":"page"},{"location":"howdoi/#How-do-I-reverse-a-dimension-so-that-an-interpolant-can-be-made?","page":"How do I?","title":"How do I reverse a dimension so that an interpolant can be made?","text":"","category":"section"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"You can use reverse_dim or reverse_dim! to reverse a dimension by name. See the example below of this usage.","category":"page"},{"location":"howdoi/","page":"How do I?","title":"How do I?","text":"# Reversing pressure levels so that an interpolant can be made\nvar_reversed = reverse_dim(var, \"pressure_level\")\nreverse_dim!(var, \"pressure_level\") # in-place","category":"page"},{"location":"developer/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"developer/#TemplateVar","page":"Developer Documentation","title":"TemplateVar","text":"","category":"section"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"warning: Reading NetCDF files\nFor most users, it is sufficient to be able to create a OutputVar by using SimDir or by reading it directly from a NetCDF file (e.g. read_var(nc_data_file)).","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"warning: Experimental feature\nThis feature is experimental, and the API may change.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"The main struct in ClimaAnalysis is OutputVar. To manually construct a OutputVar from scratch involves either making your own NetCDF file or manually defining the attributes, dimensions, dimension attributes, and data. This process is prone to errors (e.g., mismatches between dimension size and data size or mismatch between variable names) and is repetitive when initializing multiple OutputVars for testing.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"To solve this issue, we introduce TemplateVar. A TemplateVar can be thought of as an uninitialized OutputVar which is not materialized until it is called with initialize. See the example below of constructing a TemplateVar and initializing it into an OutputVar.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"using ClimaAnalysis.Template # hide\nvar =\n    Template.TemplateVar() |>\n    Template.add_attribs(long_name = \"Test\", short_name = \"test\") |>\n    Template.add_time_dim(name = \"t\", dim = collect(0.0:2.0)) |>\n    Template.add_lon_dim(units = \"degrees\") |>\n    Template.add_lat_dim(axis = \"Y\") |>\n    Template.one_to_n_data(collected = true) |>\n    Template.initialize","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"The convenience functions for adding a dimension are add_time_dim, add_lon_dim, add_lat_dim, add_pfull_dim, and add_z_dim which accept the keyword arguments dim_name, dim_array, and units. Any other keyword arguments will be used as attributes for the dimension. These functions are designed to be used with the pipe operator (|>). Additionally, there are also functions of the form add_x_dim! which are designed to be used with function composition. The x can be time, lon, lat, pfull, or z.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"The order in which dimensions are added to the TemplateVar determines their order in the OutputVar. If the same dimension is added again, then the existing dimension is overwritten with the new dimension. As a result, when defining a dimension, one must add all the dimension attributes, name of the dimension, and the dimension array at once.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"When adding multiple attributes using add_attribs or add_attribs!, existing attributes will be overwritten. There is currently no functionality to remove attributes.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"If multiple functions are provided for specifying the data, only the last one will be used.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"There is also the convenience function make_template_var which is shown below.","category":"page"},{"location":"developer/","page":"Developer Documentation","title":"Developer Documentation","text":"using ClimaAnalysis.Template # hide\n# Order of arguments determine the order of the dimensions in OutputVar\n# Names passed to `make_template_var` is not used for the names of the dimensions of the\n# OutputVar\nvar =\n    Template.make_template_var(\"t\", \"long\", \"lat\"; abc = \"def\") |>\n    Template.add_lon_dim(name = \"lon\", dim = [1.0, 2.0]) |>\n    Template.add_time_dim(name = \"t\", dim = [3.0, 4.0]) |>\n    Template.initialize","category":"page"},{"location":"developer/#API","page":"Developer Documentation","title":"API","text":"","category":"section"},{"location":"developer/#Template","page":"Developer Documentation","title":"Template","text":"","category":"section"},{"location":"developer/#ClimaAnalysis.Template.TemplateVar-Tuple{}","page":"Developer Documentation","title":"ClimaAnalysis.Template.TemplateVar","text":"TemplateVar()\n\nIntialize a TemplateVar.\n\nA TemplateVar is an uninitialized OutputVar.\n\nExamples\n\nThis example shows how to add attributes, dimensions, and data to a TemplateVar and initialize it.\n\nusing ClimaAnalysis.Template\nvar =\n    Template.TemplateVar() |>\n    Template.add_attribs(long_name = \"Test\", short_name = \"test\") |>\n    Template.add_time_dim(name = \"t\", dim = collect(0.0:2.0)) |>\n    Template.add_lon_dim(units = \"degrees\") |>\n    Template.add_lat_dim(axis = \"Y\") |>\n    Template.one_to_n_data(collected = true) |>\n    Template.initialize\n\n\n\n\n\n","category":"method"},{"location":"developer/#ClimaAnalysis.Template.initialize","page":"Developer Documentation","title":"ClimaAnalysis.Template.initialize","text":"initialize(var::TemplateVar)\n\nInitialize a TemplateVar into an OutputVar.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_attribs","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_attribs","text":"add_attribs(; attribs...)\n\nReturn the function add_attribs with the keyword arguments attribs.\n\nDesigned to be used with the pipe operator (|>).\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_attribs!","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_attribs!","text":"add_attribs!(var::TemplateVar; attribs...)\n\nAdd attributes and return var.\n\nDesigned to be used with function composition.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_dim","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_dim","text":"add_dim(dim_name, dim; dim_attribs...)\n\nAdd dim_name dimension with array dim and attributes dim_attribs.\n\nThere are the convenience functions add_time_dim, add_lon_dim, add_lat_dim, add_pfull_dim, and add_z_dim which uses default values for dim_name, dim, and units.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_dim!","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_dim!","text":"add_dim!(var::TemplateVar, dim_name, dim; dim_attribs...)\n\nAdd dim_name dimension with array dim and attributes dim_attribs.\n\nThere are the convenience functions add_time_dim!, add_lon_dim!, add_lat_dim!, add_pfull_dim!, and add_z_dim! which uses default values for dim_name, dim, and units.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_data","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_data","text":"add_data(; data)\n\nAdd data to TemplateVar.\n\nDesigned to be used with the pipe operator (|>).\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.add_data!","page":"Developer Documentation","title":"ClimaAnalysis.Template.add_data!","text":"add_data!(var::TemplateVar; data)\n\nAdd data to var.\n\nDesigned to be used with function composition.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.ones_data","page":"Developer Documentation","title":"ClimaAnalysis.Template.ones_data","text":"ones_data(; data_type = Float64)\n\nAdd ones data to TemplateVar.\n\nDesigned to be used with the pipe operator (|>).\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.ones_data!","page":"Developer Documentation","title":"ClimaAnalysis.Template.ones_data!","text":"ones_data!(var::TemplateVar; data_type = Float64)\n\nAdd ones data to var.\n\nDesigned to be used with function composition.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.zeros_data","page":"Developer Documentation","title":"ClimaAnalysis.Template.zeros_data","text":"zeros_data(; data_type = Float64)\n\nAdd zeros data to TemplateVar.\n\nDesigned to be used with the pipe operator (|>).\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.zeros_data!","page":"Developer Documentation","title":"ClimaAnalysis.Template.zeros_data!","text":"zeros_data!(var::TemplateVar; data_type = Float64)\n\nAdd zeros data to var.\n\nDesigned to be used with function composition.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.one_to_n_data","page":"Developer Documentation","title":"ClimaAnalysis.Template.one_to_n_data","text":"one_to_n_data(; data_type = Float64, collected = false)\n\nAdd data of 1:n to TemplateVar where n is the product of the sizes of the dimensions.\n\nIf collected = false, then collect is not called on the data and if collected = true, then collect is called on the data.\n\nDesigned to be used with the pipe operator (|>).\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.one_to_n_data!","page":"Developer Documentation","title":"ClimaAnalysis.Template.one_to_n_data!","text":"one_to_n_data!(var::TemplateVar; data_type = Float64, collected = false)\n\nAdd data of 1:n to var where n is the product of the sizes of the dimensions.\n\nIf collected = true, then collect is not called on the data and if collected = false, then collect is called on the data.\n\nDesigned to be used with function composition.\n\n\n\n\n\n","category":"function"},{"location":"developer/#ClimaAnalysis.Template.make_template_var","page":"Developer Documentation","title":"ClimaAnalysis.Template.make_template_var","text":"make_template_var(dims::String...; attribs...)\n\nMake a TemplateVar with the specified dimensions in dims and additional attribs.\n\nThe order of dims dictates the order of the dimensions in the OutputVar after initialization. The names of dims is not passed to the TemplateVar.\n\n\n\n\n\n","category":"function"},{"location":"flat/#FlatVar","page":"FlatVar","title":"FlatVar","text":"","category":"section"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"To help with data preparation and feeding data from OutputVars into other pipelines, ClimaAnalysis provides two functions flatten to flatten an OutputVar into a FlatVar and unflatten to unflatten a FlatVar into an OutputVar. A FlatVar consists of data which is a one-dimensional vector of the OutputVar's data and metadata which contain all the necessary information to reconstruct the original OutputVar.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"The problems that FlatVar aim to solve are","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"Flattening can be error prone if one does not keep track of the ordering of the dimensions,\nFlattening a one-dimensional vector loses important information, such as what quantity is represented by the OutputVar and the ordering of the dimensions.","category":"page"},{"location":"flat/#Flatten","page":"FlatVar","title":"Flatten","text":"","category":"section"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"To solve the first problem, ClimaAnalysis enforces the ordering of the dimensions when flattening to be (\"longitude\", \"latitude\", \"pressure\", \"altitude\", \"time\") and omits the dimensions that do not exist in the OutputVar.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"The example below demonstrates how the order of the dimensions of a OutputVar does not matter when flattening the data. The order of dimensions of flat_var is time, lon, and lat, and the order of dimensions of permuted_var is lon, lat, and time. When both OutputVars are flattened, the flattened data of both OutputVars are the same. As such, using flatten removes the need to keep track of the order of the dimensions of a OutputVar.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"var\nflat_var = ClimaAnalysis.flatten(var);\npermuted_var = permutedims(var, (\"longitude\", \"latitude\", \"time\"));\nflat_permuted_var = ClimaAnalysis.flatten(permuted_var);\nisequal(flat_permuted_var.data, flat_var.data)","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"The data can be extracted by flat_var.data and the metadata can be extracted by flatvar.metadata. More information about the metadata will discussed in the section below.","category":"page"},{"location":"flat/#Ignore-NaNs","page":"FlatVar","title":"Ignore NaNs","text":"","category":"section"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"Furthermore, if ignore_nan = true, then NaNs are excluded when flattening the data.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"count(isnan, nan_var.data) # nan_var is the same as var, but contains three NaNs\nflat_nan_var = ClimaAnalysis.flatten(nan_var, ignore_nan = true); # default is true\nlength(flat_nan_var.data)","category":"page"},{"location":"flat/#Masking","page":"FlatVar","title":"Masking","text":"","category":"section"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"In addition to ignoring NaNs, you can also pass in a ClimaAnalysis.Var.LonLatMask for the keyword argument mask_var. This will do a mask-aware flatten on the `OutputVar.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"note: Zeros and ones\nClimaAnalysis drop any values whose coordinates correspond to zero in the mask.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"# Mask map coordinates on the ocean to NaN and coordinates on the land to 1.0\nocean_mask = ClimaAnalysis.generate_ocean_mask(NaN, 1.0; threshold = 0.5)\nflat_masked_var = ClimaAnalysis.flatten(var, mask = ocean_mask)\n# All values on the ocean are not considered when flattening\nlength(flat_nan_var.data)","category":"page"},{"location":"flat/#Unflatten","page":"FlatVar","title":"Unflatten","text":"","category":"section"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"To solve the second problem, there is the metadata field in FlatVar that stores the necessary information to fully reconstruct the OutputVar. With unflatten, one can call unflatten on both FlatVar or on metadata and data to reconstruct the OutputVar. This decoupling of metadata and data also means that one needs to be careful that the correct metadata and data are being used to reconstruct the Outputvar.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"See the example below of unflattening flat_var.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"unflatten_var = ClimaAnalysis.unflatten(flat_var)\nisequal(unflatten_var.data, var.data)","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"One can also unflatten using the metadata and data of flat_var.","category":"page"},{"location":"flat/","page":"FlatVar","title":"FlatVar","text":"unflatten_var = ClimaAnalysis.unflatten(flat_var.metadata, flat_var.data)\nisequal(unflatten_var.data, var.data)","category":"page"},{"location":"read_files/#Organizing-and-loading-NetCDF-files","page":"Reading NetCDF files","title":"Organizing and loading NetCDF files","text":"","category":"section"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"ClimaAnalysis provides SimDir and NCCatalog for organizing and loading OutputVars from NetCDF files. For output from a CliMA simulation, use SimDir, and for external NetCDF files, use NCCatalog.","category":"page"},{"location":"read_files/#SimDir","page":"Reading NetCDF files","title":"SimDir","text":"","category":"section"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"For information about SimDir, see the SimDir section in the quickstart guide.","category":"page"},{"location":"read_files/#NCCatalog","page":"Reading NetCDF files","title":"NCCatalog","text":"","category":"section"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"For NetCDF files not generated from a CliMA simulation, you can use ClimaAnalysis.NCCatalog to organize and retrieve variables from the NetCDF files.","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"The first step is to instantiate a ClimaAnalysis.NCCatalog().","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"import ClimaAnalysis\n\ncatalog = ClimaAnalysis.NCCatalog()","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"To populate the catalog, you can use ClimaAnalysis.add_file!.","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"You don't need to provide short names to add_file!, but if multiple files contain the same variable name, ClimaAnalysis will load from the file that was added first. To ensure that the variable is loaded from a specific file, provide the short name (e.g., \"rsdt\") or an alias (e.g., \"precip\" => \"pr\"). If an alias is provided, then the short name of the OutputVar will be renamed accordingly.","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"ClimaAnalysis.add_file!(catalog, \"gpp.nc\")\nClimaAnalysis.add_file!(catalog, \"precip.nc\", \"precip\" => \"pr\")\nClimaAnalysis.add_file!(catalog, \"radiation.nc\", \"rsdt\", \"rsut\", \"toa_lw_all_mon\" => \"rlut\")","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"Finally, to retrieve a variable from the NCCatalog, you can call get. Additional keyword arguments for constructing the ClimaAnalysis.OutputVar can be passed as var_kwargs.","category":"page"},{"location":"read_files/","page":"Reading NetCDF files","title":"Reading NetCDF files","text":"pr_var = get(catalog, \"pr\")\nrlut_var = get(catalog, \"rsut\", var_kwargs = (shift_by = Dates.firstdayofmonth,))","category":"page"},{"location":"#ClimaAnalysis","page":"Home","title":"ClimaAnalysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaAnalysis, your one-stop-shop for all your CliMA analysis needs.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#SimDir","page":"Home","title":"SimDir","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose you ran a ClimaAtmos simulation, and the output is saved in the folder simulation_output. The first step in using ClimaAnalysis is to instantiate a SimDir:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import ClimaAnalysis\n\nsimdir = ClimaAnalysis.SimDir(\"simulation_output\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaAnalysis.SimDir scans the simulation_output, finds all the output files, and organizes them. Consider the following directories:","category":"page"},{"location":"","page":"Home","title":"Home","text":"global_diagnostics/\n output_0001\n  ta_3.0h_average.nc\n  ta_3.0h_max.nc\n  ta_3.0h_min.nc\n  ta_4.0h_max.nc\n  ts_1.0h_max.nc\n  ua_6.0h_average.nc\n  va_2.0h_average.nc\n output_0002\n  ua_6.0h_average.nc\n  va_2.0h_average.nc\n output_0003\n     ts_1.0h_max.nc\n     ua_6.0h_average.nc\n     va_2.0h_average.nc","category":"page"},{"location":"","page":"Home","title":"Home","text":"As of version 0.1.0, ClimaAnalysis uses file names to identify files and variables. In this, ClimaAnalysis assumes that the default names for outputs are used in ClimaAtmos (i.e., <short_name>_<reduction_time>_<reduction_type>.nc, as in ta_1h_max.nc, or <short_name>_1d_inst.nc).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you have a SimDir, you can inspect the output. For example, to find what variables are available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> println(summary(simdir))\nOutput directory: simulation_output\nVariables:\n- va\n    average (2.0h)\n- ua\n    average (6.0h)\n- orog\n    inst (1.0d)\n- ta\n    average (3.0h)\n    max (4.0h, 3.0h)\n    min (3.0h)\n- ts\n    max (1.0h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, you can access any given variable","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max = get(simdir; short_name = \"ts\", reduction = \"max\", period = \"3.0h\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max is a OutputVar, a type that contains the variable as well as some metadata. When there is only one combination short_name/reduction/period, the function get can be used with get(simdir, short_name) (e.g., get(simdir, \"orog\") in the previous example). In this case, you can get multiple variables at the same time with","category":"page"},{"location":"","page":"Home","title":"Home","text":"orog, ua, va = get(simdir, \"orog\", \"ua\", \"va\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If there are more files with the same combination of short name, reduction, and period, then the function get automatically stitch the .nc files together along the time dimension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Stitch `ua_6.0h_average.nc` in output_0001, output_0002, and output_0003\nua_average = get(simdir; short_name = \"ua\", reduction = \"average\", period = \"6.0h\")\n\n# Stitch `ts_1.0h_max.nc` in output_0001 and output_0003\nts_average = get(simdir; short_name = \"ts\", reduction = \"max\", period = \"1.0h\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The order of files in the directory tree traversed top-down determines the order of the files when stitching them. Stitching the datasets is not possible when the start dates are not the same, the names of the time dimension are not the same across the datasets, the time dimension does not exist, or the times are not in sequential order.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let us learn about OutputVars","category":"page"},{"location":"#OutputVar","page":"Home","title":"OutputVar","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OutputVars contain the raw data (in .data), the attributes read from the file, and the information regarding the dimension over which the variable is defined.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ts_max.dims\nOrderedCollections.OrderedDict{String, Vector{Float32}} with 4 entries:\n  \"time\" => [10800.0, 21600.0, 32400.0, 43200.0]\n  \"lon\"  => [-180.0, -177.989, -175.978, -173.966, -171.955, -169.944, -167.933, -165.922\n  \"lat\"  => [-80.0, -77.9747, -75.9494, -73.924, -71.8987, -69.8734, -67.8481, -65.8228, \n  \"z\"    => [0.0, 5000.0, 10000.0, 15000.0, 20000.0, 25000.0, 30000.0, 35000.0, 40000.0, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we have the dimensions and their values. The dimensions are ordered as in the file, so that the first index of .data is time, and so on.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can find the attributes of the dimensions in .attributes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ts_max.dim_attributes[\"lon\"]\n  \"lon\"  => Dict(\"units\"=>\"degrees_east\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the attributes are exposed with function calls. For example","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> long_name(ts_max)\n  Surface Temperature, max within 1.0 Hour(s)","category":"page"},{"location":"","page":"Home","title":"Home","text":"These function use the attributes in the NetCDF files. When not available, empty strings are returned.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given an OutputVar, we can perform manipulations. For instance, we can take the average over latitudes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max_lat_averaged = ClimaAnalysis.average_lat(ts_max)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now,","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max_lat_averaged.dims =\nOrderedCollections.OrderedDict{String, Vector{Float32}} with 3 entries:\n  \"time\" => [10800.0, 21600.0, 32400.0, 43200.0]\n  \"lon\"  => [-180.0, -177.989, -175.978, -173.966, -171.955, -169.944, -167.933, -165.922\n  \"z\"    => [0.0, 5000.0, 10000.0, 15000.0, 20000.0, 25000.0, 30000.0, 35000.0, 40000.0, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also take a time/altitude slice, for example, the plane with altitude closest to 8000 meters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max_lat_averaged_sliced = ClimaAnalysis.slice(ts_max_lat_averaged, 8_000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can also call ClimaAnalysis.slice(ts_max_lat_averaged_sliced, time = 8_000). Now,","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts_max_lat_averaged_sliced.dims =\nOrderedCollections.OrderedDict{String, Vector{Float32}} with 2 entries:\n  \"time\" => [10800.0, 21600.0, 32400.0, 43200.0]\n  \"lon\"  => [-180.0, -177.989, -175.978, -173.966, -171.955, -169.944, -167.933, -165.922","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can get the dimensions from standard names, for example, to find the times, simply run","category":"page"},{"location":"","page":"Home","title":"Home","text":"times(ts_max_lat_averaged_sliced) =\n4-element Vector{Float32}:\n 10800.0\n 21600.0\n 32400.0\n 43200.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"OutputVars can be evaluated on arbitrary points. For instance","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ts_max([12000., 23., 45., 1200.])","category":"page"},{"location":"","page":"Home","title":"Home","text":"will return the value of the maximum temperature at time 12000, longitude 23, latitude 45, and altitude 1200. This can be used to interpolate OutputVars onto new grids.","category":"page"},{"location":"#Mathematical-operations","page":"Home","title":"Mathematical operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OutputVars support the usual mathematical operations. For instance, if ts_max is an OutputVar, 2 * ts_max will be an OutputVar with doubled values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For binary operations (e.g., +, -, *, /), ClimaAnalysis will check if the operation is well defined (i.e., the two variables are defined on the physical space). Binary operations do remove some attribute information. If two OutputVars share the same start date, then the start date will remain in the resulting OutputVars after performing binary operations on them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unary operations are supported to, for example log(max(var, 1e-8)) returns a new OutputVar with the functions applied to the data.","category":"page"},{"location":"#Visualize","page":"Home","title":"Visualize","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can directly visualize OutputVars.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If Makie is available, ClimaAnalysis can be used for plotting. Importing Makie and ClimaAnalysis in the same session automatically loads the necessary ClimaAnalysis plotting modules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we want to make a heatmap for ts_max at time of 100 s at altitude z of 30000 meters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import CairoMakie\nimport ClimaAnalysis.Visualize as viz\n\nfig = CairoMakie.Figure(size = (400, 600))\n\nviz.plot!(\n  fig,\n  ts_max,\n  time = 100.0,\n  z = 30_000.0\n)\n\nCairoMakie.save(\"ts_max.png\", fig)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we want to have a line plot, we can simply add another argument (e.g., lat = 30), to slice through that value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to customize some of the properties, you can pass the more_kwargs to the plot! function. more_kwargs is a dictionary that can contain additional arguments to the Axis (:axis), plot (:plot), and Colorbar (:cb) functions. more_kwargs is a Dictionary that maps the symbols :axis, :plot, and :cb to their additional arguments. For instance, to choose the alpha value of the plot, the label of the colorbar, and the subtitle, you can do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"viz.plot!(\n    fig,\n    ts_max,\n    time = 100.0,\n    z = 30_000.0,\n    more_kwargs = Dict(\n        :plot => Dict(:alpha => 0.5),\n        :cb => Dict(:label => \"My label\"),\n        :axis => Dict(:subtitle => \"My subtitle\"),\n    ),\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note the Symbol in plot, cb, and axis!. :plot, :cb, and :axis have to be a mapping of Symbols and values. ClimaAnalysis has a convenience function kwargs to more easily pass down the keyword arguments avoiding this step. With that, the above example becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"import ClimaAnalysis.Utils : kwargs as ca_kwargs\nviz.plot!(\n  fig,\n  ts_max,\n  time = 100.0,\n  z = 30_000.0,\n  more_kwargs = Dict(\n      :plot => ca_kwargs(alpha = 0.5),\n      :cb => ca_kwargs(label = \"My label\"),\n      :axis => ca_kwargs(subtitle = \"My subtitle\"),\n  ),\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"With Utils.kwargs, you can just pass the arguments as you would pass them to the constructor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need more control over the placement of plots, you can pass Makie.GridLayout objects to the plotting functions. For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nfig = Figure()\nlayout = fig[1, 2] = GridLayout()\n\nviz.plot!(\n  layout,\n  ts_max,\n  time = 100.0,\n  z = 30_000.0,\n  more_kwargs = Dict(\n      :plot => ca_kwargs(alpha = 0.5),\n      :cb => ca_kwargs(label = \"My label\"),\n      :axis => ca_kwargs(subtitle = \"My subtitle\"),\n  ),\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"When you pass a GridLayout, the optional argument p_loc refers to the placement within the layout. When you pass a Figure, it refers to the placement within the figure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have GeoMakie and are working on a variable defined on a long-lat grid, you can directly plot on a projected global surface. For that, load GeoMakie and use the heatmap2D_on_globe! function.","category":"page"},{"location":"var/#OutputVars","page":"OutputVars","title":"OutputVars","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"OutputVars are the heart of ClimaAnalysis. This page is under construction, in the meantime, consult OutputVar.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"OutputVars can be directly generated from most NetCDF files. Just pass the path to the constructor:","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"import ClimaAnalysis: OutputVar\n\nmyfile = OutputVar(\"my_netcdf_file.nc\")","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"ClimaAnalysis will try to find a variable in this file. If multiple are available, ClimaAnalysis picks the latest in alphabetical order. If you want to specify one, pass it to the constructor:","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"import ClimaAnalysis: OutputVar\n\nmyfile = OutputVar(\"my_netcdf_file.nc\", \"myvar\")","category":"page"},{"location":"var/#Physical-units","page":"OutputVars","title":"Physical units","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"OutputVars can contain information about their physical units. For OutputVars read from NetCDF files, this is obtained from the units attribute (and stored in the attributes[\"units\"]).","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"When possible, ClimaAnalysis uses Unitful to handle units. This enables automatic unit conversion for OutputVars.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Consider the following example:","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"import ClimaAnalysis\nvalues = 0:100.0 |> collect\ndata = copy(values)\nattribs = Dict(\"long_name\" => \"speed\", \"units\" => \"m/s\")\ndim_attribs = Dict{String, Any}()\nvar = ClimaAnalysis.OutputVar(attribs, Dict(\"distance\" => values), dim_attribs, data)\n\nvar_cms = ClimaAnalysis.convert_units(var, \"cm/s\")","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"In this example, we set upvar, an OutputVar with units of meters per second. Then, we called ClimaAnalysis.convert_units to convert the units to centimeters per second.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Sometimes, this automatic unit conversion is not possible (e.g., when you want to transform between incompatible units). In this case, you can pass a function that specify how to apply this transformation. For example, in the previous case, we can assume that we are talking about water and transform units into a mass flux:","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"new_var = ClimaAnalysis.convert_units(var, \"kg m/s\", conversion_function = (x) -> 1000x)","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"note: Unparseable units\nIf you find some unparseable units, please open an issue. We can fix them!","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"If units do not exist, or you want to change the name of the units, then one can use the set_units function.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"new_var = ClimaAnalysis.set_units(var, \"kg m s^-1\")","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"For converting the units of a dimension, you can use ClimaAnalysis.convert_dim_units. As of now, automatic conversion is not supported which means you need to supply the conversion function. See the example below.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"new_var = ClimaAnalysis.convert_dim_units(\n        var,\n        \"lat\",\n        \"rads\",\n        conversion_function = x -> x *  / 180.0,\n    )","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Similarly, to set the units of a dimension, you can use the dim_set_units! function.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"new_var = ClimaAnalysis.set_dim_units!(var, \"lon\", \"degrees_east\")","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"warning: Override existing units\nIf units already exist, this will override the units for data or the dimension in var.","category":"page"},{"location":"var/#Interpolations-and-extrapolations","page":"OutputVars","title":"Interpolations and extrapolations","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Interpolating a OutputVar onto coordinates can be done by doing the following:","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"var((0.0, 0.0)) # var is a two-dimensional OutputVar","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"A multilinear interpolation is used to determine the value at the coordinate (0, 0).","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"warning: Interpolate on dates\nIf any of the dimensions contains Dates.DateTime elements, interpolation is not possible. Interpolations.jl does not support interpolating on dates.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Extrapolating is supported only on the longitude and latitude dimensions. For the longitude and latitude dimensions, a periodic boundary condition and a flat boundary condition are added, respectively, when the dimension array is equispaced and spans the entire range. For all other cases, extrapolating beyond the domain of the dimension will throw an error.","category":"page"},{"location":"var/#Preprocess-dates-and-seconds","page":"OutputVars","title":"Preprocess dates and seconds","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"When loading a NetCDF file, dates in the time dimension are automatically converted to seconds and a start date is added to the attributes of the OutputVar. This is done because ClimaAnalysis does not support interpolating on dates which mean functions that rely on the interpolats, such as resampled_as, will not work otherwise.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Two additional parameters are provided to help preprocess dates which are new_start_date and shift_by. If new_start_date is provided, then dates in the time dimension will automatically be converted with reference to the new_start_date rather than the first date found in the NetCDF file. The parameter new_start_date can be any string parseable by the Dates module or a Dates.DateTime object. If additional preprocessing is needed, then one can provide a function that takes in and returns a Date.DateTime object. This function is applied to each date before converting each dates to seconds with reference with the start date.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"# Shift the dates to first day of month, convert to seconds, and adjust seconds to\n# match the date 1/1/2010\nobs_var = ClimaAnalysis.OutputVar(\n                \"pr.nc\",\n                \"precip\",\n                new_start_date = \"2010-01-01T00:00:00\", # or Dates.DateTime(2010, 1, 1)\n                shift_by = Dates.firstdayofmonth,\n            )","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Additionally, the function shift_to_start_of_previous_month(var::OutputVar) is provided to help with preprocessing. This function shifts the times in the time dimension to the start of the previous month. After applying this function, the start date in the attributes corresponds to the first element in the time array.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"sim_var = shift_to_start_of_previous_month(sim_var)","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"This function is helpful in ensuring consistency in dates between simulation and observational data. One example of this is when adjusting monthly averaged data. For instance, suppose that data on 2010-02-01 in sim_var corresponds to the monthly average for January. This function shifts the times so that 2010-01-01 will correspond to the monthly average for January.","category":"page"},{"location":"var/#Integration","page":"OutputVars","title":"Integration","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"OutputVars can be integrated with respect to longitude, latitude, or both using integrate_lon(var), integrate_lat(var), or integrate_lonlat(var) respectively. The bounds of integration are determined by the range of the dimensions longitude and latitude in var. The unit of both longitude and latitude should be degree.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"If the points are equispaced, it is assumed that each point correspond to the midpoint of a cell which results in rectangular integration using the midpoint rule. Otherwise, the integration being done is rectangular integration using the left endpoints for integrating longitude and latitude.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"See the example of integrating over a sphere where the data is all ones to find the surface area of a sphere.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"julia> lon = collect(range(-179.5, 179.5, 360));\n\njulia> lat = collect(range(-89.5, 89.5, 180));\n\njulia> data = ones(length(lon), length(lat));\n\njulia> dims = OrderedDict([\"lon\" => lon, \"lat\" => lat]);\n\njulia> dim_attribs = OrderedDict([\n           \"lon\" => Dict(\"units\" => \"degrees_east\"),\n           \"lat\" => Dict(\"units\" => \"degrees_north\"),\n       ]);\n\njulia> attribs = Dict(\"long_name\" => \"f\");\n\njulia> var = ClimaAnalysis.OutputVar(attribs, dims, dim_attribs, data);\n\njulia> integrated_var = integrate_lonlat(var);\n\njulia> integrated_var.dims # no dimensions since longitude and latitude are integrated out\nOrderedDict{String, Vector{Float64}}()\n\njulia> integrated_var.data # approximately 4 (the surface area of a sphere)\n0-dimensional Array{Float64, 0}:\n12.566530113084296\n\njulia> long_name(integrated_var) # updated long name to reflect the data being integrated\n\"f integrated over lon (-179.5 to 179.5degrees_east) and integrated over lat (-89.5 to 89.5degrees_north)\"","category":"page"},{"location":"var/#Split-by-season","page":"OutputVars","title":"Split by season","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"OutputVars can be split by seasons using split_by_season(var) provided that a start date can be found in var.attributes[\"start_date\"] and time is a dimension in the OutputVar. The unit of time is expected to be second. The function split_by_season(var) returns a vector of four OutputVars with each OutputVar corresponding to a season. The months of the seasons are March to May, June to August, September to November, and December to February. The order of the vector is MAM, JJA, SON, and DJF. If there are no dates found for a season, then the OutputVar for that season will be an empty OutputVar.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"var.attributes\nClimaAnalysis.times(var) # correspond to dates 2024-1-1, 2024-3-1, 2024-6-1\nvar.data\nMAM, JJA, SON, DJF = ClimaAnalysis.split_by_season(var);\nisempty(SON) # empty OutputVar because no dates between September to November\n[MAM.dims[\"time\"], JJA.dims[\"time\"], DJF.dims[\"time\"]]\n[MAM.data, JJA.data, DJF.data]","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"note: `seasons` keyword argument\nIn ClimaAnalysis v0.5.18, the seasons keyword argument allows you to change the order of the seasons or select only certain seasons. For example, you can call split_by_season(var, seasons = (\"DJF\", \"SON\")) to extract only the seasons DJF and SON, in that order.","category":"page"},{"location":"var/#Split-by-season-and-year","page":"OutputVars","title":"Split by season and year","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"It may be the case that you want to split a OutputVar by season, while keeping each year separate. This is different from split_by_season, which ignores that seasons can come from different years. This can be done by using split_by_season_across_time. For example, if a OutputVar contains times corresponding to 2010-01-01, 2010-03-01, 2010-06-01, 2010-09-01, and 2010-12-01, then the result of split_by_season_across_time is five OutputVars, each corresponding to a distinct date. Even though 2010-01-01 and 2010-12-01 are in the same season, there are two OutputVars, because the dates do not belong in the same season and year.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"var.attributes[\"start_date\"]\nClimaAnalysis.times(var) # dates from the first of January, March, June, August, and December\nsplit_var = ClimaAnalysis.split_by_season_across_time(var);\nlength(split_var) # months span over 5 seasons\nClimaAnalysis.times(split_var[1]) # correspond to 1/1 (middle of DJF)\nClimaAnalysis.times(split_var[2]) # correspond to 3/1 (start of MAM)\nClimaAnalysis.times(split_var[3]) # correspond to 6/1 (start of JJA)\nClimaAnalysis.times(split_var[4]) # correspond to 9/1 (start of SON)\nClimaAnalysis.times(split_var[5]) # correspond to 12/1 (start of DJF)","category":"page"},{"location":"var/#Bias-and-squared-error","page":"OutputVars","title":"Bias and squared error","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Bias and squared error can be computed from simulation data and observational data in OutputVars using bias(sim, obs) and squared_error(sim, obs). The function bias(sim, obs) returns a OutputVar whose data is the bias (sim.data - obs.data) and computes the  global bias of data in sim and obs over longitude and latitude. The result is stored in var.attributes[\"global_bias\"]. The function squared_error(sim, obs) returns a OutputVar whose data is the squared error ((sim.data - obs.data)^2) and computes the global mean squared error (MSE) and the global root mean squared error (RMSE) of data in sim and obs over longitude and latitude. The result is stored in var.attributes[\"global_mse\"] and var.attributes[\"global_rmse\"]. Resampling is automatically done by resampling obs on sim. If you are only interested in computing global bias, MSE, or RMSE, you can use global_bias(sim, obs), global_mse(sim, obs), or global_rmse(sim, obs).","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"As of now, these functions are implemented for OutputVars with only the dimensions longitude and latitude. Furthermore, units must be supplied for data and dimensions in sim and obs and the units for longitude and latitude should be degrees.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Consider the following example, where we compute the bias and RMSE between our simulation and some observations stored in ta_1d_average.nc.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"julia> obs_var = OutputVar(\"ta_1d_average.nc\"); # load in observational data\n\njulia> sim_var = get(simdir(\"simulation_output\"), \"ta\"); # load in simulation data\n\njulia> ClimaAnalysis.short_name(sim_var)\n\"ta\"\n\njulia> bias_var = ClimaAnalysis.bias(sim_var, obs_var); # bias_var is a OutputVar that can be plotted\n\njulia> ClimaAnalysis.global_bias(sim, obs)\n2.0\n\njulia> ClimaAnalysis.units(bias_var)\n\"K\"\n\njulia> se_var = ClimaAnalysis.squared_error(sim_var, obs_var); # can also be plotted\n\njulia> ClimaAnalysis.global_mse(sim, obs)\n4.0\n\njulia> ClimaAnalysis.global_rmse(sim, obs)\n2.0\n\njulia> ClimaAnalysis.units(se_var)\n\"K^2\"","category":"page"},{"location":"var/#3D-OutputVars","page":"OutputVars","title":"3D OutputVars","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"For three-dimensional variables that have dimensions longitude, latitude, and z, pressure, or time, the functions mentioned before will not work. To compute the bias or squared error, one can use ClimaAnalysis.slice to slice across the z, pressure, or time dimension to get a 2D variable defined on longitude and latitude. Then, any of the functions mentioned earlier will work. See an example of this below, where the bias and global MSE are computed between two OutputVars, where the time dimension is sliced at one day from the start date.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"# Load in 3D temperature variable defined over longitude, latitude, and time\njulia> obs_var = OutputVar(\"ta_1d_average.nc\"); # load in observational data\n\n# Load in 3D temperature variable defined over longitude, latitude, and time\njulia> sim_var = get(simdir(\"simulation_output\"), \"ta\"); # load in simulation data\n\n# Slice to get variables defined over longitude and latitude\njulia> obs_var = ClimaAnalysis.slice(obs_var, time =  86400)\n\njulia> sim_var = ClimaAnalysis.slice(sim_var, time =  86400)\n\njulia> ClimaAnalysis.bias(sim_var, obs_var);\n\njulia> ClimaAnalysis.global_mse(sim, obs)\n4.0","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"For 3D variables defined over longitude, latitude, and pressure, one can find the global RMSE in pressure space using ClimaAnalysis.global_rmse_pfull. See an example of this below, where global RMSE is computed between 3D variables in pressure space.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"# Load in 3D temperature variable defined over longitude, latitude, and pressure\njulia> obs_var = OutputVar(\"era5_pfull_ta_data.nc\"); # load in observational data\n\n# Load in 3D temperature variable defined over longitude, latitude, and z\njulia> sim_var = get(simdir(\"simulation_output\"), \"ta\"); # load in simulation data\n\n# Load in 3D pressure variable defined over longitude, latitude, and z\njulia> pressure_3D_var = get(simdir(\"simulation_output\"), \"pfull\"); # load in simulation data\n\n# This function will automatically converts to pressure coordinates for `sim_var` and\n# `obs_var` if the keywords `sim_pressure` and `obs_pressure` are supplied respectively\njulia> ClimaAnalysis.global_rmse_pfull(sim_var, obs_var, sim_pressure = pressure_3D_var)\n3.4","category":"page"},{"location":"var/#Masking","page":"OutputVars","title":"Masking","text":"","category":"section"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"Bias and squared error can be computed only over the land or ocean through the mask parameter. As of now, the mask parameter takes in apply_oceanmask or apply_oceanmask. See the example below of this usage.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"# Do not consider the ocean when computing the bias\nClimaAnalysis.bias(sim_var, obs_var, mask = apply_oceanmask)\nClimaAnalysis.global_bias(sim_var, obs_var, mask = apply_oceanmask)\n\n# Do not consider the land when computing the squared error\nClimaAnalysis.squared_error(sim_var, obs_var, mask = apply_landmask)\nClimaAnalysis.global_mse(sim_var, obs_var, mask = apply_landmask)\nClimaAnalysis.global_rmse(sim_var, obs_var, mask = apply_landmask)","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"In other cases, you may want to generate a masking function using a OutputVar. For instance, you are comparing against observational data over some parts of the land, and you can't use an ocean mask, since not all the observational data is defined over the land. The function generate_lonlat_mask allows you to generate a masking function. If the data is already zeros and ones, then you can use generate_lonlat_mask(var, zero_to, one_to) which generate a mask where all ones are replaced with one_to and zeros are replaced with zero_to. If this is not the case, then you can use replace or replace! to make the data all zeros and ones. You can also use the threshold keyword argument to adjust how the values are rounded after resampling from the data of zeros and ones. Values greater than or equal to threshold are rounded to one and all other values are rounded to zero.","category":"page"},{"location":"var/","page":"OutputVars","title":"OutputVars","text":"# var is a OutputVar whose data is ones and NaN\nvar = replace(x -> isnan(x) ? 0.0 : 1.0, var)\n\n# Any points that are NaNs should be zero in the mask\nlonlat_mask = ClimaAnalysis.generate_lonlat_mask(\n    var,\n    NaN, # zero to NaN\n    1.0; # one to one\n    threshold = 0.99\n)\n\n# Apply mask to another OutputVar\nanother_masked_var = lonlat_mask(another_var)\n\n# Compute squared error and global MSE with custom masking function\nClimaAnalysis.squared_error(sim_var, obs_var, mask = lonlat_mask)\nClimaAnalysis.global_mse(sim_var, obs_var, mask = lonlat_mask)","category":"page"}]
}
