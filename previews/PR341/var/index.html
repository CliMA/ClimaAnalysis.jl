<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OutputVars · ClimaAnalysis.jl</title><meta name="title" content="OutputVars · ClimaAnalysis.jl"/><meta property="og:title" content="OutputVars · ClimaAnalysis.jl"/><meta property="twitter:title" content="OutputVars · ClimaAnalysis.jl"/><meta name="description" content="Documentation for ClimaAnalysis.jl."/><meta property="og:description" content="Documentation for ClimaAnalysis.jl."/><meta property="twitter:description" content="Documentation for ClimaAnalysis.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaAnalysis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>OutputVars</a><ul class="internal"><li><a class="tocitem" href="#Physical-units"><span>Physical units</span></a></li><li><a class="tocitem" href="#Interpolations-and-extrapolations"><span>Interpolations and extrapolations</span></a></li><li><a class="tocitem" href="#Preprocess-dates-and-seconds"><span>Preprocess dates and seconds</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li><li><a class="tocitem" href="#Split-by-season"><span>Split by season</span></a></li><li><a class="tocitem" href="#Bias-and-squared-error"><span>Bias and squared error</span></a></li><li><a class="tocitem" href="#Masking"><span>Masking</span></a></li></ul></li><li><a class="tocitem" href="../visualize/">Visualizing OutputVars</a></li><li><a class="tocitem" href="../read_files/">Reading NetCDF files</a></li><li><a class="tocitem" href="../rmse_var/">RMSEVariables</a></li><li><a class="tocitem" href="../visualize_rmse_var/">Visualizing RMSEVariables</a></li><li><a class="tocitem" href="../flat/">FlatVar</a></li><li><a class="tocitem" href="../api/">APIs</a></li><li><a class="tocitem" href="../howdoi/">How do I?</a></li><li><a class="tocitem" href="../developer/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>OutputVars</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OutputVars</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaAnalysis.jl/blob/main/docs/src/var.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OutputVars"><a class="docs-heading-anchor" href="#OutputVars"><code>OutputVar</code>s</a><a id="OutputVars-1"></a><a class="docs-heading-anchor-permalink" href="#OutputVars" title="Permalink"></a></h1><p><code>OutputVar</code>s are the heart of <code>ClimaAnalysis</code>. This page is under construction, in the meantime, consult <a href="../#OutputVar"><code>OutputVar</code></a>.</p><p><code>OutputVar</code>s can be directly generated from most NetCDF files. Just pass the path to the constructor:</p><pre><code class="language-julia hljs">import ClimaAnalysis: OutputVar

myfile = OutputVar(&quot;my_netcdf_file.nc&quot;)</code></pre><p><code>ClimaAnalysis</code> will try to find a variable in this file. If multiple are available, <code>ClimaAnalysis</code> picks the latest in alphabetical order. If you want to specify one, pass it to the constructor:</p><pre><code class="language-julia hljs">import ClimaAnalysis: OutputVar

myfile = OutputVar(&quot;my_netcdf_file.nc&quot;, &quot;myvar&quot;)</code></pre><h2 id="Physical-units"><a class="docs-heading-anchor" href="#Physical-units">Physical units</a><a id="Physical-units-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-units" title="Permalink"></a></h2><p><code>OutputVar</code>s can contain information about their physical units. For <code>OutputVar</code>s read from NetCDF files, this is obtained from the <code>units</code> attribute (and stored in the <code>attributes[&quot;units&quot;]</code>).</p><p>When possible, <code>ClimaAnalysis</code> uses <a href="https://painterqubits.github.io/Unitful.jl/stable">Unitful</a> to handle units. This enables automatic unit conversion for <code>OutputVar</code>s.</p><p>Consider the following example:</p><pre><code class="language-julia hljs">import ClimaAnalysis
values = 0:100.0 |&gt; collect
data = copy(values)
attribs = Dict(&quot;long_name&quot; =&gt; &quot;speed&quot;, &quot;units&quot; =&gt; &quot;m/s&quot;)
dim_attribs = Dict{String, Any}()
var = ClimaAnalysis.OutputVar(attribs, Dict(&quot;distance&quot; =&gt; values), dim_attribs, data)

var_cms = ClimaAnalysis.convert_units(var, &quot;cm/s&quot;)</code></pre><p>In this example, we set up<code>var</code>, an <code>OutputVar</code> with units of meters per second. Then, we called <a href="../api/#ClimaAnalysis.Var.convert_units"><code>ClimaAnalysis.convert_units</code></a> to convert the units to centimeters per second.</p><p>Sometimes, this automatic unit conversion is not possible (e.g., when you want to transform between incompatible units). In this case, you can pass a function that specify how to apply this transformation. For example, in the previous case, we can assume that we are talking about water and transform units into a mass flux:</p><pre><code class="language-julia hljs">new_var = ClimaAnalysis.convert_units(var, &quot;kg m/s&quot;, conversion_function = (x) -&gt; 1000x)</code></pre><div class="admonition is-info" id="Unparseable-units-b9f0b544847774cc"><header class="admonition-header">Unparseable units<a class="admonition-anchor" href="#Unparseable-units-b9f0b544847774cc" title="Permalink"></a></header><div class="admonition-body"><p>If you find some unparseable units, please open an issue. We can fix them!</p></div></div><p>If units do not exist, or you want to change the name of the units, then one can use the <code>set_units</code> function.</p><pre><code class="language-julia hljs">new_var = ClimaAnalysis.set_units(var, &quot;kg m s^-1&quot;)</code></pre><p>For converting the units of a dimension, you can use <a href="../api/#ClimaAnalysis.Var.convert_dim_units"><code>ClimaAnalysis.convert_dim_units</code></a>. As of now, automatic conversion is not supported which means you need to supply the conversion function. See the example below.</p><pre><code class="language-julia hljs">new_var = ClimaAnalysis.convert_dim_units(
        var,
        &quot;lat&quot;,
        &quot;rads&quot;,
        conversion_function = x -&gt; x * π / 180.0,
    )</code></pre><p>Similarly, to set the units of a dimension, you can use the <code>dim_set_units!</code> function.</p><pre><code class="language-julia hljs">new_var = ClimaAnalysis.set_dim_units!(var, &quot;lon&quot;, &quot;degrees_east&quot;)</code></pre><div class="admonition is-warning" id="Override-existing-units-97062d15cf323be9"><header class="admonition-header">Override existing units<a class="admonition-anchor" href="#Override-existing-units-97062d15cf323be9" title="Permalink"></a></header><div class="admonition-body"><p>If units already exist, this will override the units for data or the dimension in <code>var</code>.</p></div></div><h2 id="Interpolations-and-extrapolations"><a class="docs-heading-anchor" href="#Interpolations-and-extrapolations">Interpolations and extrapolations</a><a id="Interpolations-and-extrapolations-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolations-and-extrapolations" title="Permalink"></a></h2><p>Interpolating a <code>OutputVar</code> onto coordinates can be done by doing the following:</p><pre><code class="language-julia hljs">var((0.0, 0.0)) # var is a two-dimensional OutputVar</code></pre><p>A multilinear interpolation is used to determine the value at the coordinate (0, 0).</p><div class="admonition is-warning" id="Interpolate-on-dates-645a032223899019"><header class="admonition-header">Interpolate on dates<a class="admonition-anchor" href="#Interpolate-on-dates-645a032223899019" title="Permalink"></a></header><div class="admonition-body"><p>If any of the dimensions contains <code>Dates.DateTime</code> elements, interpolation is not possible. <code>Interpolations.jl</code> does not support interpolating on dates.</p></div></div><p>Extrapolating is supported only on the longitude and latitude dimensions. For the longitude and latitude dimensions, a periodic boundary condition and a flat boundary condition are added, respectively, when the dimension array is equispaced and spans the entire range. For all other cases, extrapolating beyond the domain of the dimension will throw an error.</p><h2 id="Preprocess-dates-and-seconds"><a class="docs-heading-anchor" href="#Preprocess-dates-and-seconds">Preprocess dates and seconds</a><a id="Preprocess-dates-and-seconds-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocess-dates-and-seconds" title="Permalink"></a></h2><p>When loading a NetCDF file, dates in the time dimension are automatically converted to seconds and a start date is added to the attributes of the <code>OutputVar</code>. This is done because <code>ClimaAnalysis</code> does not support interpolating on dates which mean functions that rely on the interpolats, such as <code>resampled_as</code>, will not work otherwise.</p><p>Two additional parameters are provided to help preprocess dates which are <code>new_start_date</code> and <code>shift_by</code>. If <code>new_start_date</code> is provided, then dates in the time dimension will automatically be converted with reference to the <code>new_start_date</code> rather than the first date found in the NetCDF file. The parameter <code>new_start_date</code> can be any string parseable by the <a href="https://docs.julialang.org/en/v1/stdlib/Dates/">Dates</a> module or a <code>Dates.DateTime</code> object. If additional preprocessing is needed, then one can provide a function that takes in and returns a <code>Date.DateTime</code> object. This function is applied to each date before converting each dates to seconds with reference with the start date.</p><pre><code class="language- hljs"># Shift the dates to first day of month, convert to seconds, and adjust seconds to
# match the date 1/1/2010
obs_var = ClimaAnalysis.OutputVar(
                &quot;pr.nc&quot;,
                &quot;precip&quot;,
                new_start_date = &quot;2010-01-01T00:00:00&quot;, # or Dates.DateTime(2010, 1, 1)
                shift_by = Dates.firstdayofmonth,
            )</code></pre><p>Additionally, the function <code>shift_to_start_of_previous_month(var::OutputVar)</code> is provided to help with preprocessing. This function shifts the times in the time dimension to the start of the previous month. After applying this function, the start date in the attributes corresponds to the first element in the time array.</p><pre><code class="language- hljs">sim_var = shift_to_start_of_previous_month(sim_var)</code></pre><p>This function is helpful in ensuring consistency in dates between simulation and observational data. One example of this is when adjusting monthly averaged data. For instance, suppose that data on 2010-02-01 in <code>sim_var</code> corresponds to the monthly average for January. This function shifts the times so that 2010-01-01 will correspond to the monthly average for January. See also <a href="../api/#ClimaAnalysis.Var.shift_to_previous_day"><code>shift_to_previous_day</code></a> and <a href="../api/#ClimaAnalysis.Var.shift_to_previous_week"><code>shift_to_previous_week</code></a> for diagnostics whose time reductions span a day or week respectively.</p><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p><code>OutputVar</code>s can be integrated with respect to longitude, latitude, or both using <code>integrate_lon(var)</code>, <code>integrate_lat(var)</code>, or <code>integrate_lonlat(var)</code> respectively. The bounds of integration are determined by the range of the dimensions longitude and latitude in <code>var</code>. The unit of both longitude and latitude should be degree.</p><p>If the points are equispaced, it is assumed that each point correspond to the midpoint of a cell which results in rectangular integration using the midpoint rule. Otherwise, the integration being done is rectangular integration using the left endpoints for integrating longitude and latitude.</p><p>See the example of integrating over a sphere where the data is all ones to find the surface area of a sphere.</p><pre><code class="language- hljs">julia&gt; lon = collect(range(-179.5, 179.5, 360));

julia&gt; lat = collect(range(-89.5, 89.5, 180));

julia&gt; data = ones(length(lon), length(lat));

julia&gt; dims = OrderedDict([&quot;lon&quot; =&gt; lon, &quot;lat&quot; =&gt; lat]);

julia&gt; dim_attribs = OrderedDict([
           &quot;lon&quot; =&gt; Dict(&quot;units&quot; =&gt; &quot;degrees_east&quot;),
           &quot;lat&quot; =&gt; Dict(&quot;units&quot; =&gt; &quot;degrees_north&quot;),
       ]);

julia&gt; attribs = Dict(&quot;long_name&quot; =&gt; &quot;f&quot;);

julia&gt; var = ClimaAnalysis.OutputVar(attribs, dims, dim_attribs, data);

julia&gt; integrated_var = integrate_lonlat(var);

julia&gt; integrated_var.dims # no dimensions since longitude and latitude are integrated out
OrderedDict{String, Vector{Float64}}()

julia&gt; integrated_var.data # approximately 4π (the surface area of a sphere)
0-dimensional Array{Float64, 0}:
12.566530113084296

julia&gt; long_name(integrated_var) # updated long name to reflect the data being integrated
&quot;f integrated over lon (-179.5 to 179.5degrees_east) and integrated over lat (-89.5 to 89.5degrees_north)&quot;</code></pre><h2 id="Split-by-season"><a class="docs-heading-anchor" href="#Split-by-season">Split by season</a><a id="Split-by-season-1"></a><a class="docs-heading-anchor-permalink" href="#Split-by-season" title="Permalink"></a></h2><p><code>OutputVar</code>s can be split by seasons using <code>split_by_season(var)</code> provided that a start date can be found in <code>var.attributes[&quot;start_date&quot;]</code> and time is a dimension in the <code>OutputVar</code>. The unit of time is expected to be second. The function <code>split_by_season(var)</code> returns a vector of four <code>OutputVar</code>s with each <code>OutputVar</code> corresponding to a season. The months of the seasons are March to May, June to August, September to November, and December to February. The order of the vector is MAM, JJA, SON, and DJF. If there are no dates found for a season, then the <code>OutputVar</code> for that season will be an empty <code>OutputVar</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; var.attributes</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, String} with 1 entry:
  &quot;start_date&quot; =&gt; &quot;2024-1-1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(var) # correspond to dates 2024-1-1, 2024-3-1, 2024-6-1</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 5.184e6
 1.31328e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; var.data</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 2.0
 3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MAM, JJA, SON, DJF = ClimaAnalysis.split_by_season(var);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isempty(SON) # empty OutputVar because no dates between September to November</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [MAM.dims[&quot;time&quot;], JJA.dims[&quot;time&quot;], DJF.dims[&quot;time&quot;]]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{Float64}}:
 [5.184e6]
 [1.31328e7]
 [0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [MAM.data, JJA.data, DJF.data]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{Float64}}:
 [2.0]
 [3.0]
 [1.0]</code></pre><div class="admonition is-info" id="seasons-keyword-argument-2be7db705fed5c4e"><header class="admonition-header">`seasons` keyword argument<a class="admonition-anchor" href="#seasons-keyword-argument-2be7db705fed5c4e" title="Permalink"></a></header><div class="admonition-body"><p>In ClimaAnalysis v0.5.18, the <code>seasons</code> keyword argument allows you to change the order of the seasons or select only certain seasons. For example, you can call <code>split_by_season(var, seasons = (&quot;DJF&quot;, &quot;SON&quot;))</code> to extract only the seasons <code>DJF</code> and <code>SON</code>, in that order.</p></div></div><h3 id="Split-by-season-and-year"><a class="docs-heading-anchor" href="#Split-by-season-and-year">Split by season and year</a><a id="Split-by-season-and-year-1"></a><a class="docs-heading-anchor-permalink" href="#Split-by-season-and-year" title="Permalink"></a></h3><p>It may be the case that you want to split a <code>OutputVar</code> by season, while keeping each year separate. This is different from <code>split_by_season</code>, which ignores that seasons can come from different years. This can be done by using <code>split_by_season_across_time</code>. For example, if a <code>OutputVar</code> contains times corresponding to 2010-01-01, 2010-03-01, 2010-06-01, 2010-09-01, and 2010-12-01, then the result of <code>split_by_season_across_time</code> is five <code>OutputVar</code>s, each corresponding to a distinct date. Even though 2010-01-01 and 2010-12-01 are in the same season, there are two <code>OutputVar</code>s, because the dates do not belong in the same season and year.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; var.attributes[&quot;start_date&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;2010-1-1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(var) # dates from the first of January, March, June, August, and December</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 0.0
 5.0976e6
 1.30464e7
 2.09952e7
 2.88576e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; split_var = ClimaAnalysis.split_by_season_across_time(var);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(split_var) # months span over 5 seasons</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(split_var[1]) # correspond to 1/1 (middle of DJF)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(split_var[2]) # correspond to 3/1 (start of MAM)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 5.0976e6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(split_var[3]) # correspond to 6/1 (start of JJA)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 1.30464e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(split_var[4]) # correspond to 9/1 (start of SON)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 2.09952e7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ClimaAnalysis.times(split_var[5]) # correspond to 12/1 (start of DJF)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 2.88576e7</code></pre><h2 id="Bias-and-squared-error"><a class="docs-heading-anchor" href="#Bias-and-squared-error">Bias and squared error</a><a id="Bias-and-squared-error-1"></a><a class="docs-heading-anchor-permalink" href="#Bias-and-squared-error" title="Permalink"></a></h2><p>Bias and squared error can be computed from simulation data and observational data in <code>OutputVar</code>s using <code>bias(sim, obs)</code> and <code>squared_error(sim, obs)</code>. The function <code>bias(sim, obs)</code> returns a <code>OutputVar</code> whose data is the bias (<code>sim.data - obs.data</code>) and computes the  global bias of <code>data</code> in <code>sim</code> and <code>obs</code> over longitude and latitude. The result is stored in <code>var.attributes[&quot;global_bias&quot;]</code>. The function <code>squared_error(sim, obs)</code> returns a <code>OutputVar</code> whose data is the squared error (<code>(sim.data - obs.data)^2</code>) and computes the global mean squared error (MSE) and the global root mean squared error (RMSE) of <code>data</code> in <code>sim</code> and <code>obs</code> over longitude and latitude. The result is stored in <code>var.attributes[&quot;global_mse&quot;]</code> and <code>var.attributes[&quot;global_rmse&quot;]</code>. Resampling is automatically done by resampling <code>obs</code> on <code>sim</code>. If you are only interested in computing global bias, MSE, or RMSE, you can use <code>global_bias(sim, obs)</code>, <code>global_mse(sim, obs)</code>, or <code>global_rmse(sim, obs)</code>.</p><p>As of now, these functions are implemented for <code>OutputVar</code>s with only the dimensions longitude and latitude. Furthermore, units must be supplied for data and dimensions in <code>sim</code> and <code>obs</code> and the units for longitude and latitude should be degrees.</p><p>Consider the following example, where we compute the bias and RMSE between our simulation and some observations stored in <code>ta_1d_average.nc</code>.</p><pre><code class="language- hljs">julia&gt; obs_var = OutputVar(&quot;ta_1d_average.nc&quot;); # load in observational data

julia&gt; sim_var = get(simdir(&quot;simulation_output&quot;), &quot;ta&quot;); # load in simulation data

julia&gt; ClimaAnalysis.short_name(sim_var)
&quot;ta&quot;

julia&gt; bias_var = ClimaAnalysis.bias(sim_var, obs_var); # bias_var is a OutputVar that can be plotted

julia&gt; ClimaAnalysis.global_bias(sim, obs)
2.0

julia&gt; ClimaAnalysis.units(bias_var)
&quot;K&quot;

julia&gt; se_var = ClimaAnalysis.squared_error(sim_var, obs_var); # can also be plotted

julia&gt; ClimaAnalysis.global_mse(sim, obs)
4.0

julia&gt; ClimaAnalysis.global_rmse(sim, obs)
2.0

julia&gt; ClimaAnalysis.units(se_var)
&quot;K^2&quot;</code></pre><h3 id="3D-OutputVars"><a class="docs-heading-anchor" href="#3D-OutputVars">3D <code>OutputVar</code>s</a><a id="3D-OutputVars-1"></a><a class="docs-heading-anchor-permalink" href="#3D-OutputVars" title="Permalink"></a></h3><p>For three-dimensional variables that have dimensions longitude, latitude, and z, pressure, or time, the functions mentioned before will not work. To compute the bias or squared error, one can use <code>ClimaAnalysis.slice</code> to slice across the z, pressure, or time dimension to get a 2D variable defined on longitude and latitude. Then, any of the functions mentioned earlier will work. See an example of this below, where the bias and global MSE are computed between two <code>OutputVar</code>s, where the time dimension is sliced at one day from the start date.</p><pre><code class="language- hljs"># Load in 3D temperature variable defined over longitude, latitude, and time
julia&gt; obs_var = OutputVar(&quot;ta_1d_average.nc&quot;); # load in observational data

# Load in 3D temperature variable defined over longitude, latitude, and time
julia&gt; sim_var = get(simdir(&quot;simulation_output&quot;), &quot;ta&quot;); # load in simulation data

# Slice to get variables defined over longitude and latitude
julia&gt; obs_var = ClimaAnalysis.slice(obs_var, time =  86400)

julia&gt; sim_var = ClimaAnalysis.slice(sim_var, time =  86400)

julia&gt; ClimaAnalysis.bias(sim_var, obs_var);

julia&gt; ClimaAnalysis.global_mse(sim, obs)
4.0</code></pre><p>For 3D variables defined over longitude, latitude, and pressure, one can find the global RMSE in pressure space using <code>ClimaAnalysis.global_rmse_pfull</code>. See an example of this below, where global RMSE is computed between 3D variables in pressure space.</p><pre><code class="language- hljs"># Load in 3D temperature variable defined over longitude, latitude, and pressure
julia&gt; obs_var = OutputVar(&quot;era5_pfull_ta_data.nc&quot;); # load in observational data

# Load in 3D temperature variable defined over longitude, latitude, and z
julia&gt; sim_var = get(simdir(&quot;simulation_output&quot;), &quot;ta&quot;); # load in simulation data

# Load in 3D pressure variable defined over longitude, latitude, and z
julia&gt; pressure_3D_var = get(simdir(&quot;simulation_output&quot;), &quot;pfull&quot;); # load in simulation data

# This function will automatically converts to pressure coordinates for `sim_var` and
# `obs_var` if the keywords `sim_pressure` and `obs_pressure` are supplied respectively
julia&gt; ClimaAnalysis.global_rmse_pfull(sim_var, obs_var, sim_pressure = pressure_3D_var)
3.4</code></pre><h2 id="Masking"><a class="docs-heading-anchor" href="#Masking">Masking</a><a id="Masking-1"></a><a class="docs-heading-anchor-permalink" href="#Masking" title="Permalink"></a></h2><p>Bias and squared error can be computed only over the land or ocean through the <code>mask</code> parameter. As of now, the mask parameter takes in <code>apply_oceanmask</code> or <code>apply_oceanmask</code>. See the example below of this usage.</p><pre><code class="language-julia hljs"># Do not consider the ocean when computing the bias
ClimaAnalysis.bias(sim_var, obs_var, mask = apply_oceanmask)
ClimaAnalysis.global_bias(sim_var, obs_var, mask = apply_oceanmask)

# Do not consider the land when computing the squared error
ClimaAnalysis.squared_error(sim_var, obs_var, mask = apply_landmask)
ClimaAnalysis.global_mse(sim_var, obs_var, mask = apply_landmask)
ClimaAnalysis.global_rmse(sim_var, obs_var, mask = apply_landmask)</code></pre><p>In other cases, you may want to generate a masking function using a <code>OutputVar</code>. For instance, you are comparing against observational data over some parts of the land, and you can&#39;t use an ocean mask, since not all the observational data is defined over the land. The function <code>generate_lonlat_mask</code> allows you to generate a masking function. If the data is already zeros and ones, then you can use <code>generate_lonlat_mask(var, zero_to, one_to)</code> which generate a mask where all ones are replaced with <code>one_to</code> and zeros are replaced with <code>zero_to</code>. If this is not the case, then you can use <code>replace</code> or <code>replace!</code> to make the data all zeros and ones. You can also use the <code>threshold</code> keyword argument to adjust how the values are rounded after resampling from the data of zeros and ones. Values greater than or equal to <code>threshold</code> are rounded to one and all other values are rounded to zero.</p><pre><code class="language-julia hljs"># var is a OutputVar whose data is ones and NaN
var = replace(x -&gt; isnan(x) ? 0.0 : 1.0, var)

# Any points that are NaNs should be zero in the mask
lonlat_mask = ClimaAnalysis.generate_lonlat_mask(
    var,
    NaN, # zero to NaN
    1.0; # one to one
    threshold = 0.99
)

# Apply mask to another OutputVar
another_masked_var = lonlat_mask(another_var)

# Compute squared error and global MSE with custom masking function
ClimaAnalysis.squared_error(sim_var, obs_var, mask = lonlat_mask)
ClimaAnalysis.global_mse(sim_var, obs_var, mask = lonlat_mask)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../visualize/">Visualizing OutputVars »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 23:07">Wednesday 15 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
